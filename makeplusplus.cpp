#include <algorithm>
#include <random>
#include <format>
#include <ranges>
#include <iostream>
#include <fstream>
#include <filesystem>

#include "tinyxml2/tinyxml2.h"
#include "cpod.hpp"
#include "makeplusplus.hpp"

namespace makexx {

    //////////////////////////////////////////////////////////////
    ///             Header related functionalities             ///
    //////////////////////////////////////////////////////////////

    void put_default_content(cpod::archive& arch) {
        arch << cpod::com("This header is generated by makeplusplus.");
        static constexpr std::string_view header_names[] = {
            "cstdint", "string", "vector", "list", "deque", "forward_list", "map", "unordered_map",
            "set", "unordered_set"
        };
        for (auto& i : header_names) {
            arch << cpod::txt("#include <{:s}>\n", i);
        }
        arch << '\n';

        // Define CPP_STD enums.
        arch << cpod::def("MXX_STD_CPP_LATEST", "1");
        arch << cpod::def("MXX_STD_CPP11", "2");
        arch << cpod::def("MXX_STD_CPP14", "3");
        arch << cpod::def("MXX_STD_CPP17", "4");
        arch << cpod::def("MXX_STD_CPP20", "5");
        arch << cpod::def("MXX_STD_CPP23", "6");
        arch << cpod::def("MXX_STD_CPP26", "7") << '\n';

        // Define C_STD enums.
        arch << cpod::def("MXX_STD_C_LATEST", "1");
        arch << cpod::def("MXX_STD_C11", "2");
        arch << cpod::def("MXX_STD_C17", "3");
        arch << cpod::def("MXX_STD_C23", "4") << '\n';

        // Define target type enums.
        arch << cpod::def("MXX_TARGET_TYPE_EXE", "1");
        arch << cpod::def("MXX_TARGET_TYPE_LIB", "2");
        arch << cpod::def("MXX_TARGET_TYPE_DLL", "3") << '\n';

        // Define optimization level enums
        arch << cpod::def("MXX_OPTIMIZATION_0", "1");
        arch << cpod::def("MXX_OPTIMIZATION_1", "2");
        arch << cpod::def("MXX_OPTIMIZATION_2", "3");
        arch << cpod::def("MXX_OPTIMIZATION_3", "4") << '\n';

        arch << cpod::def("MXX_MSVC_SUBSYSTEM_CONSOLE", "1");
        arch << cpod::def("MXX_MSVC_SUBSYSTEM_WINDOW",  "2") << '\n';

#define TYPE_AND_VAR_STRING(type, var) #type" "#var
        // Project define macros.
        arch << cpod::def("PROJECT_NAME",            TYPE_AND_VAR_STRING(std::string              , mxx_project_name));
        arch << cpod::def("PROJECT_TARGETS",         TYPE_AND_VAR_STRING(std::vector<std::string> , mxx_project_targets));
        arch << cpod::def("PROJECT_CONFIGURATIONS",  TYPE_AND_VAR_STRING(std::vector<std::string> , mxx_project_configurations)) << '\n';

        // Target define macros.
        arch << cpod::def("TARGET_SOURCES",                          TYPE_AND_VAR_STRING(std::vector<std::string> , mxx_target_sources));
        arch << cpod::def("TARGET_HEADERS",                          TYPE_AND_VAR_STRING(std::vector<std::string> , mxx_target_headers));
        arch << cpod::def("TARGET_DEPENDENCIES",                     TYPE_AND_VAR_STRING(std::vector<std::string> , mxx_target_dependencies));
        arch << cpod::def("TARGET_DEFINES",                          TYPE_AND_VAR_STRING(std::vector<std::string> , mxx_target_defines));
        arch << cpod::def("TARGET_EXTERNAL_LINKS",                   TYPE_AND_VAR_STRING(std::vector<std::string> , mxx_target_external_links));
        arch << cpod::def("TARGET_EXTERNAL_LINK_DIRECTORIES",        TYPE_AND_VAR_STRING(std::vector<std::string> , mxx_target_external_link_directories));
        arch << cpod::def("TARGET_EXTERNAL_INCLUDE_DIRECTORIES",     TYPE_AND_VAR_STRING(std::vector<std::string> , mxx_target_external_include_directories)) << '\n';
        
        arch << cpod::def("TARGET_BINARY_DIRECTORY",      TYPE_AND_VAR_STRING(std::string , mxx_target_binary_directory));
        arch << cpod::def("TARGET_INTERMEDIATE_DIRECTORY",TYPE_AND_VAR_STRING(std::string , mxx_target_intermediate_directory)) << '\n';

        arch << cpod::def("TARGET_TYPE" ,           TYPE_AND_VAR_STRING(uint32_t , mxx_target_type));
        arch << cpod::def("TARGET_STD_CPP",         TYPE_AND_VAR_STRING(uint32_t , mxx_target_std_cpp));
        arch << cpod::def("TARGET_STD_C",           TYPE_AND_VAR_STRING(uint32_t , mxx_target_std_c));
        arch << cpod::def("TARGET_OPTIMIZATION",    TYPE_AND_VAR_STRING(uint32_t , mxx_target_optimization)) << '\n';
        
        arch << cpod::def("TARGET_MSVC_ICON",       TYPE_AND_VAR_STRING(std::string , mxx_target_msvc_icon));
        arch << cpod::def("TARGET_MSVC_SUBSYSTEM",  TYPE_AND_VAR_STRING(uint32_t    , mxx_target_msvc_subsystem)) << '\n';

#undef TYPE_AND_VAR_STRING
    }

    std::string put_header_archive_to_buffer(const std::unordered_map<std::string_view, std::string>& defmap) {
        // Header file contains
        // 1. Your building system.
        // 2. Your executable path.
        // You don't need to define three above
        // Other macros defined in defmap would be added to the header with this three together.

        // I don't have plan to support mac or any apple platform (xcode project)
        // So basically besides on windows you are going to use visual studio
        // Makefile will work on all non window platforms.

        cpod::archive arch;
        put_default_content(arch);
        
        std::string current_path = std::filesystem::current_path().lexically_normal().generic_string() + "/";
        arch << cpod::def("MXX_EXE_PATH", std::format("\"{:s}\"", current_path));
#ifdef _WIN32
        arch << cpod::def("MXX_SYSTEM_WINDOWS", "\"windows\"");
        arch << cpod::def("MXX_SYSTEM", "MXX_SYSTEM_WINDOWS");
#elifdef __linux__
        arch << cpod::def("MXX_SYSTEM_LINUX", "\"linux\"");
        arch << cpod::def("MXX_SYSTEM", "MXX_SYSTEM_LINUX");
#else
        arch << cpod::def("MXX_SYSTEM_REAL_UNIX", "\"unix\"");
        arch << cpod::def("MXX_SYSTEM", "MXX_SYSTEM_UNIX");
#endif
        // Write all custom macros.
        for (auto& [key, val] : defmap) {
            arch << cpod::def(key, val);
        }
        return arch.content();
    }

    void get_header_archive_from_buffer(cpod::archive& arch, std::unordered_map<std::string_view, std::string>& defmap) {
        cpod::cpp_subset_compiler compiler(std::move(arch.content()));

        compiler.remove_comments(); compiler.src = compiler.out;             
        compiler.get_macro_define_map(defmap);
        arch.content() = std::move(compiler.src);

        for (auto& i : defmap) {
            cpod::cpp_subset_compiler::expand_macro_value(defmap, i.first);
        }
    }

    namespace msvc_details {

        static std::string           normalize_to_uppercase_mode(std::string_view mode) {
            std::string mode_upper_norm;
            std::ranges::transform(mode, std::back_inserter(mode_upper_norm), [](auto i) { return std::toupper(i); });
            return mode_upper_norm;
        }

        template <typename F>
        static std::string           convert_list_to_string(const std::vector<std::string>& links, std::string_view suffix, F op) {
            std::string result;
            for (auto& i : links) {
                result.append(op(i)).append(suffix).push_back(';');
            }
            result.pop_back();
            return result;
        }
        
        static tinyxml2::XMLElement* xml_find_child_with_index(std::string_view name, tinyxml2::XMLElement* root, std::size_t n = 0) {
            tinyxml2::XMLElement* element = root->FirstChildElement(name.data());
            for (std::size_t i = 0; i != n; ++i) {
                element = element->NextSiblingElement(name.data());
            }
            return element;
        }

        static void                  xml_save_map_to_file(std::unordered_map<std::string_view, tinyxml2::XMLDocument>& map, std::string_view ext, std::string_view rootdir = "") {
            for (auto& [target_name, doc] : map) {
                std::filesystem::path path = (std::filesystem::path(rootdir) / (std::string(target_name) + std::string(ext))).lexically_normal();
                if (doc.SaveFile(path.generic_string().c_str()) != tinyxml2::XML_SUCCESS) {
                    std::cerr << "Error saving " << ext << " file " << target_name << std::endl;
                    std::exit(EXIT_FAILURE);
                }
            }
        }

        static tinyxml2::XMLElement* xml_find_child_with_attribute(std::string_view name, tinyxml2::XMLElement* root, std::string_view attrib, std::string_view value) {
            root = root->FirstChildElement(name.data());
            for (; value != root->FindAttribute(attrib.data())->Value(); root = root->NextSiblingElement(name.data())) {}
            return root;
        }
        
        static std::string generate_guid() {
            std::random_device rd{};
            std::default_random_engine eng{ rd() };
            std::uniform_int_distribution<std::size_t> distrib{};
    
            return std::format("{{{:08X}-{:04X}-{:04X}-{:04X}-{:08X}{:04X}}}",
                distrib(eng) % 0xFFFFFFFF, distrib(eng) % 0xFFFF, distrib(eng) % 0xFFFF, distrib(eng) % 0xFFFF,
                distrib(eng) % 0xFFFFFFFF, distrib(eng) % 0xFFFF);
        }

        static const char* get_project_type_string(target_types type) {
            static const char* types[] = { "",  "Application", "StaticLibrary", "DynamicLibrary" };
            return types[static_cast<std::uint32_t>(type)];
        }

        static const char* get_cpp_standard_string(target_cpp_standards standard) {
            static const char* standards[] = { "", "stdcpplatest", "stdcpp11", "stdcpp14", "stdcpp17", "stdcpp20", "stdcpp23", "stdcpp26" };
            return standards[static_cast<std::uint32_t>(standard)];
        }

        static const char* get_c_standard_string(target_c_standards standard) {
            static const char* standards[] = { "", "stdclatest", "stdc11", "stdc17", "stdc23" };
            return standards[static_cast<std::uint32_t>(standard)];
        }

        static const char* get_subsystem_string(target_msvc_subsystems sys) {
            static const char* systems[] = { "", "Console", "Windows" };
            return systems[static_cast<std::uint32_t>(sys)];
        }

        static const char* get_optimization_string(target_optimizations op) {
            static const char* optimizations[] = { "",  "Disabled", "MinSize", "MaxSpeed", "Full" };
            return optimizations[static_cast<std::uint32_t>(op)];
        }

        static tinyxml2::XMLElement* find_item_definition_group_element(tinyxml2::XMLDocument& doc, std::string_view condition, std::string_view subrange) {
            return xml_find_child_with_attribute("ItemDefinitionGroup",
                doc.RootElement(),
                "Condition", condition)->FirstChildElement(subrange.data());
        }
        
        static auto  extract_config(std::string_view config) {
            std::size_t      split = config.find('_');
            std::string      mode(config.substr(split + 1));
            std::string      plat(config.substr(0, split));
            std::string      tag  = std::format("{:s}|{:s}", mode, plat);
            std::string      comb = std::format("'$(Configuration)|$(Platform)'=='{:s}'",tag);
            return std::make_tuple(mode, plat, tag, comb);
        }

        static void  generate_resource(std::string_view target_name, std::string_view iconname) {
            std::ofstream rc(std::string(target_name) + ".rc"), header(std::string(target_name) + ".resource.h");

            rc << std::format(R"(
// Microsoft Visual C++ generated resource script.
//
#include "{0:s}.resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "{0:s}.resource.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#include ""winres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Icon
//

// Icon with lowest ID value placed first to ensure application icon
// remains consistent on all systems.
IDI_ICON1               ICON                    "{1:s}"

#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED)", target_name, iconname);

            header << R"(
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
//
#define IDI_ICON1                       101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
)";
            rc.close();
            header.close();
        }
    }

    /////////////////////////////////////////////////////////////
    //     Header and Sources only have little differences.    //
    /////////////////////////////////////////////////////////////
    
    void visual_studio_project::target_attach_files_(std::string_view target_name, const std::vector<std::string>& files,
                                                     std::string_view filter, AttachmentType type) {
        static const char* itemStrings[] = { "", "ClInclude", "ClCompile", "Image", "ResourceCompile" };
        
        // Add filter to list.
        tinyxml2::XMLDocument& docfilt = vcxproj_filters_map_[target_name];
        tinyxml2::XMLElement*  itemGroupFileFilter = msvc_details::xml_find_child_with_index("ItemGroup", docfilt.RootElement(), type);
        
        if (!filter.empty() && !vcxproj_filter_name_map_.contains(filter)) {
            vcxproj_filter_name_map_[filter] = filter;
            msvc_details::xml_find_child_with_index("ItemGroup", docfilt.RootElement())
            ->InsertNewChildElement("Filter")->SetAttribute("Include", filter.data())
            ->InsertNewChildElement("UniqueIdentifier")->SetText(msvc_details::generate_guid().c_str());
        }
        
        tinyxml2::XMLDocument& docproj = vcxproj_map_[target_name];
        tinyxml2::XMLElement*  itemGroupFiles = msvc_details::xml_find_child_with_index("ItemGroup", docproj.RootElement(), type);

        for (auto& i : files) {
            itemGroupFiles->InsertNewChildElement(itemStrings[type])->SetAttribute("Include", i.c_str());
            
            tinyxml2::XMLElement* fclItem = itemGroupFileFilter->InsertNewChildElement(itemStrings[type]);
            fclItem->SetAttribute("Include", i.c_str());
            if (!filter.empty()) {
                fclItem->InsertNewChildElement("Filter")->SetText(filter.data());
            }
        }
    }

    void visual_studio_project::target_set_item_definition_group_(std::string_view target_name, std::string_view config,
        std::string_view scope, std::string_view elem, std::string_view value) {
        auto [mode, plat, tag, comb] = msvc_details::extract_config(config);
        msvc_details::find_item_definition_group_element(vcxproj_map_[target_name], comb,
    scope.data())->InsertNewChildElement(elem.data())->SetText(value.data());
    }

    void visual_studio_project::target_append_property_group_(std::string_view target_name, std::string_view condition,
        std::string_view scope, std::string_view value) {
        auto [mode, plat, tag, comb] = msvc_details::extract_config(condition);
        auto prop = msvc_details::xml_find_child_with_attribute("PropertyGroup", vcxproj_map_[target_name].RootElement(), "Label", "UserMacros")
        ->NextSiblingElement("PropertyGroup");
        for (;comb != prop->Attribute("Condition"); prop = prop->NextSiblingElement("PropertyGroup")) {}
        prop->InsertNewChildElement(scope.data())->SetText(value.data());
    }


    visual_studio_project::visual_studio_project(std::string_view sln_name, const std::vector<std::string_view>& configs)
    : solution_name_(sln_name), solution_configs_(configs) {
        
    }

    visual_studio_project& visual_studio_project::new_target(std::string_view target_name) {

        ////////////////////////////////////////////
        //                Filters                ///
        ////////////////////////////////////////////
        tinyxml2::XMLDocument& docfilt = vcxproj_filters_map_[target_name];
        docfilt.InsertEndChild(docfilt.NewDeclaration("xml version=\"1.0\" encoding=\"utf-8\""));
        docfilt.InsertEndChild(docfilt.NewComment("Project generated by makeplusplus"));
        
        // Insert filter root project.
        tinyxml2::XMLElement* filter = docfilt.NewElement("Project");
        filter->SetAttribute("ToolsVersion", "4.0")->SetAttribute("xmlns", "http://schemas.microsoft.com/developer/msbuild/2003");
        docfilt.InsertEndChild(filter);

        filter->InsertNewComment("Global   filter defines")->ParentElement()->InsertNewChildElement("ItemGroup");
        filter->InsertNewComment("Header   filter defines")->ParentElement()->InsertNewChildElement("ItemGroup");
        filter->InsertNewComment("Source   filter defines")->ParentElement()->InsertNewChildElement("ItemGroup");
        filter->InsertNewComment("Icon     filter defines")->ParentElement()->InsertNewChildElement("ItemGroup");
        filter->InsertNewComment("Resource filter defines")->ParentElement()->InsertNewChildElement("ItemGroup");
        
        ////////////////////////////////////////////
        //                Project                ///
        ////////////////////////////////////////////
        vcxproj_guid_map_[target_name] = msvc_details::generate_guid();
        tinyxml2::XMLDocument& docproj = vcxproj_map_[target_name];

        docproj.InsertEndChild(docproj.NewDeclaration("xml version=\"1.0\" encoding=\"utf-8\""));
        docproj.InsertEndChild(docproj.NewComment("Project generated by makeplusplus"));

        // Insert project root declarations.
        tinyxml2::XMLElement* project = docproj.NewElement("Project");
        project->SetAttribute("DefaultTargets", "Build")->SetAttribute("xmlns", "http://schemas.microsoft.com/developer/msbuild/2003");
        docproj.InsertEndChild(project);

        // Insert ItemGroup project configurations
        tinyxml2::XMLElement* itemGroupConfig = project->InsertNewChildElement("ItemGroup")->SetAttribute("Label", "ProjectConfigurations");
        for (std::string_view config : solution_configs_) {
            auto[mode, plat, tag, comb] = msvc_details::extract_config(config);
            itemGroupConfig->InsertNewChildElement("ProjectConfiguration")->SetAttribute("Include", tag.c_str())
            ->InsertNewChildElement("Configuration")->SetText(mode.c_str()) ->ParentElement()
            ->InsertNewChildElement("Platform")     ->SetText(plat.c_str()) ->ParentElement();
        }

        // Insert global configurations
        project->InsertNewChildElement("PropertyGroup")->SetAttribute("Label", "Globals")
        ->InsertNewChildElement("ProjectGuid")                  ->SetText(vcxproj_guid_map_[target_name].c_str()) ->ParentElement()
        ->InsertNewChildElement("RootNamespace")                ->SetText(target_name.data())                     ->ParentElement()
        ->InsertNewChildElement("ProjectName")                  ->SetText(target_name.data())                     ->ParentElement()
        ->InsertNewChildElement("WindowsTargetPlatformVersion") ->SetText("10.0");
        
        // Import compile properties
        project->InsertNewChildElement("Import")->SetAttribute("Project", "$(VCTargetsPath)\\Microsoft.Cpp.Default.props");

        // Insert configuration.
        for (std::string_view config : solution_configs_) {
            auto[mode, plat, tag, comb] = msvc_details::extract_config(config);
            std::string mode_upper_norm = msvc_details::normalize_to_uppercase_mode(mode);
            
            project->InsertNewChildElement("PropertyGroup")
            ->SetAttribute("Condition", comb.c_str())->SetAttribute("Label", "Configuration")
            ->InsertNewChildElement("ConfigurationType") ->SetText("")            ->ParentElement()
            ->InsertNewChildElement("PlatformToolset")   ->SetText("v143")        ->ParentElement()
            ->InsertNewChildElement("CharacterSet")      ->SetText("Unicode")     ->ParentElement()
            ->InsertNewChildElement("UseDebugLibraries") ->SetText(mode_upper_norm == "DEBUG");
        }
        project->InsertNewChildElement("Import")->SetAttribute("Project", "$(VCTargetsPath)\\Microsoft.Cpp.props");

        // Import extension property list.
        project->InsertNewChildElement("ImportGroup")->SetAttribute("Label", "ExtensionSettings");
        project->InsertNewChildElement("ImportGroup")->SetAttribute("Label", "Shared");

        // Use for loop to set all config releated properties.
        for (std::string_view config : solution_configs_) {
            auto[mode, plat, tag, comb] = msvc_details::extract_config(config);
            project->InsertNewChildElement("ImportGroup")
            ->SetAttribute("Label", "PropertySheets")->SetAttribute("Condition", comb.c_str())
            ->InsertNewChildElement("Import")
            ->SetAttribute("Project", "$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props")
            ->SetAttribute("Condition", "exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')")
            ->SetAttribute("Label", "LocalAppDataPlatform");
        }

        project->InsertNewChildElement("PropertyGroup")->SetAttribute("Label", "UserMacros");
        
        for (std::string_view config : solution_configs_) {
            auto[mode, plat, tag, comb] = msvc_details::extract_config(config);
            project->InsertNewChildElement("PropertyGroup")->SetAttribute("Condition", comb.c_str());
        }
        
        // Insert item definitions.
        for (std::string_view config : solution_configs_) {
            auto[mode, plat, tag, comb] = msvc_details::extract_config(config);

            std::string mode_upper_norm = msvc_details::normalize_to_uppercase_mode(mode);
            
            auto* idg = project->InsertNewChildElement("ItemDefinitionGroup")->SetAttribute("Condition", comb.c_str());
            
            auto* com = idg->InsertNewChildElement("ClCompile");
                  com->InsertNewChildElement("WarningLevel")        ->SetText("Level3")  ->ParentElement()
                     ->InsertNewChildElement("SDLCheck")            ->SetText(true)      ->ParentElement()
                     ->InsertNewChildElement("ConformanceMode")     ->SetText(true)      ->ParentElement();
            auto* lnk = idg->InsertNewChildElement("Link");
                  lnk->InsertNewChildElement("GenerateDebugInformation")  ->SetText(true)    ->ParentElement();
            // Release specific defines
            if (mode_upper_norm != "DEBUG") {
                com->InsertNewChildElement("FunctionLevelLinking")->SetText(true)    ->ParentElement()
                   ->InsertNewChildElement("IntrinsicFunctions")  ->SetText(true)    ->ParentElement();
                lnk->InsertNewChildElement("EnableCOMDATFolding") ->SetText(true)    ->ParentElement()
                   ->InsertNewChildElement("OptimizeReferences")  ->SetText(true)    ->ParentElement();
            }
        }

        // include item group sequence 'project configuration''include' 'compile' 'icon' ‘resource’ 'dependencies' 
        project->InsertNewComment("Include items")   ->ParentElement()->InsertNewChildElement("ItemGroup");
        project->InsertNewComment("Source items")    ->ParentElement()->InsertNewChildElement("ItemGroup");
        project->InsertNewChildElement("Import")     ->SetAttribute("Project", "$(VCTargetsPath)\\Microsoft.Cpp.targets");
        project->InsertNewChildElement("ImportGroup")->SetAttribute("Label", "ExtensionTargets");
        project->InsertNewComment("Icon Item")       ->ParentElement()->InsertNewChildElement("ItemGroup");
        project->InsertNewComment("Resource Item")   ->ParentElement()->InsertNewChildElement("ItemGroup");
        project->InsertNewComment("Dependency items")->ParentElement()->InsertNewChildElement("ItemGroup");
        
        return *this;
    }

    visual_studio_project& visual_studio_project::target_headers(std::string_view target_name,
        const std::vector<std::string>& headers, std::string_view filter) {
        target_attach_files_(target_name, headers, filter, Attach_Headers);
        return *this;        
    }

    visual_studio_project& visual_studio_project::target_sources(std::string_view target_name,
        const std::vector<std::string>& sources, std::string_view filter) {
        target_attach_files_(target_name, sources, filter, Attach_Sources);
        return *this;
    }

    visual_studio_project& visual_studio_project::target_icon(std::string_view target_name, std::string_view resource) {
        msvc_details::generate_resource(target_name, resource);
        target_attach_files_(target_name, {std::string(resource)}, "", Attach_Icon);
        target_attach_files_(target_name, {std::string(target_name) + ".rc"}, "", Attach_Resource);
        return *this;
    }

    visual_studio_project& visual_studio_project::target_dependencies(std::string_view target_name,
        const std::vector<std::string>& dependencies) {
        tinyxml2::XMLDocument& docproj   = vcxproj_map_[target_name];
        tinyxml2::XMLElement*  itemGroup = msvc_details::xml_find_child_with_index("ItemGroup", docproj.RootElement(), Attach_Dependency);
        for (std::string_view dependency : dependencies) {
            itemGroup->InsertNewChildElement("ProjectReference")->SetAttribute("Include",  (std::string(dependency) + ".vcxproj").c_str())
            ->InsertNewChildElement("Project")->SetText(vcxproj_guid_map_[dependency].c_str());
        }
        return *this;
    }

    visual_studio_project& visual_studio_project::target_type(std::string_view target_name, target_types type) {
        tinyxml2::XMLDocument& docproj   = vcxproj_map_[target_name];
        tinyxml2::XMLElement*  propgroup = msvc_details::xml_find_child_with_index("PropertyGroup", docproj.RootElement(), 1);
        for (auto& config : solution_configs_) {
            propgroup->FirstChildElement("ConfigurationType")->SetText(msvc_details::get_project_type_string(type));
            propgroup = propgroup->NextSiblingElement("PropertyGroup");
        }
        return *this;
    }

    visual_studio_project& visual_studio_project::target_cpp_standard(std::string_view target_name,
        target_cpp_standards  version) {
        for (auto& config : solution_configs_) {
            target_set_item_definition_group_(target_name, config,
                "ClCompile", "LanguageStandard", msvc_details::get_cpp_standard_string(version));
        }
        return *this;
    }

    visual_studio_project& visual_studio_project::target_c_standard(std::string_view target_name,
        target_c_standards version) {
        for (auto& config : solution_configs_) {
            target_set_item_definition_group_(target_name, config,
                "ClCompile", "LanguageStandard_C", msvc_details::get_c_standard_string(version));
        }
        return *this;
    }

    visual_studio_project& visual_studio_project::target_msvc_subsystem(std::string_view target_name,
        target_msvc_subsystems sys) {
        for (auto& config : solution_configs_) {
            target_set_item_definition_group_(target_name, config,
                "Link", "SubSystem", msvc_details::get_subsystem_string(sys));
        }
        return *this;
    }

    visual_studio_project& visual_studio_project::target_config_optimization(std::string_view target_name,
        std::string_view config, target_optimizations op) {
        target_set_item_definition_group_(target_name, config,
    "ClCompile", "Optimization", msvc_details::get_optimization_string(op));
        return *this;
    }

    visual_studio_project& visual_studio_project::target_config_defines(std::string_view target_name,
        std::string_view config, const std::vector<std::string>& defines) {
        auto nmode = msvc_details::normalize_to_uppercase_mode(std::get<0>(msvc_details::extract_config(config)));
        std::string_view mac = nmode == "DEBUG" ? "_DEBUG" : "NDEBUG";
        target_set_item_definition_group_(target_name, config,
            "ClCompile", "PreprocessorDefinitions", std::format("{:s};{:s};%(PreprocessorDefinitions)",
                msvc_details::convert_list_to_string(defines, "", [](const std::string& i) { return i; }), mac));
        return *this;
    }

    visual_studio_project& visual_studio_project::target_link_directories(std::string_view target_name,
        const std::vector<std::string>& dirs) {
        for (auto& config : solution_configs_) {
            target_set_item_definition_group_(target_name, config,
        "Link", "AdditionalLibraryDirectories",
        msvc_details::convert_list_to_string(dirs, "", [](const std::string& i) {
                     return std::filesystem::path(i).lexically_normal().generic_string();
            }));
        }
        return *this;
    }

    visual_studio_project& visual_studio_project::target_include_directories(std::string_view target_name,
        const std::vector<std::string>& dirs) {
        for (auto& config : solution_configs_) {
            target_set_item_definition_group_(target_name, config,
        "ClCompile", "AdditionalIncludeDirectories",
        msvc_details::convert_list_to_string(dirs, "", [](const std::string& i) {
                     return std::filesystem::path(i).lexically_normal().generic_string();
            }));
        }
        return *this;
    }

    visual_studio_project& visual_studio_project::target_config_external_links(std::string_view target_name,
                                                                        std::string_view config, const std::vector<std::string>& links) {
        target_set_item_definition_group_(target_name, config,
            "Link", "AdditionalDependencies",
            std::format("{:s};%(AdditionalDependencies)", msvc_details::convert_list_to_string(links, ".lib",
                 [](const std::string& i) { return i; })));
        return *this;
    }

    visual_studio_project& visual_studio_project::target_config_out_directory(std::string_view target_name,
        std::string_view config, std::string_view dir) {
        target_append_property_group_(target_name, config, "OutDir", dir);
        return *this;
    }

    visual_studio_project& visual_studio_project::target_config_int_directory(std::string_view target_name,
        std::string_view config, std::string_view dir) {
        target_append_property_group_(target_name, config, "IntDir", dir);
        return *this;
    }

    void visual_studio_project::save_project_to_file(std::string_view root) {
        // Solution file generator generates only the necessary part
        // Won't contain visual studio version.
        std::ofstream solution(std::string(root) + solution_name_ + ".sln");
        solution << "Microsoft Visual Studio Solution File, Format Version 12.00\n";
        std::string sln_guid = msvc_details::generate_guid();
        for (const auto target : vcxproj_guid_map_ | std::views::keys) {
            solution << std::format("Project(\"{0:s}\") = \"{1:s}\", \"{1:s}.vcxproj\", \"{2:s}\"\n", sln_guid, target, vcxproj_guid_map_[target]);
            solution << "EndProject\n";
        }
        solution << "Global\n";
        solution << "    GlobalSection(SolutionConfigurationPlatforms) = preSolution\n";
        for (auto& config : solution_configs_) {
            auto[mode, plat, tag, comb] = msvc_details::extract_config(config);
            solution << std::format("        {0:s} = {0:s}\n", tag);
        }
        solution << "    EndGlobalSection\n";
        solution << "    GlobalSection(ProjectConfigurationPlatforms) = postSolution\n";
        for (auto& guid : vcxproj_guid_map_ | std::views::values) {
            for (auto& config : solution_configs_) {
                auto[mode, plat, tag, comb] = msvc_details::extract_config(config);
                solution << std::format("        {0:s}.{1:s}.ActiveCfg = {1:s}\n", guid, tag);
                solution << std::format("        {0:s}.{1:s}.Build.0 = {1:s}\n", guid, tag);
            }
        }
        solution << "    EndGlobalSection\n";
        solution << "	 GlobalSection(SolutionProperties) = preSolution\n";
        solution << "        HideSolutionNode = FALSE\n";
        solution << "    EndGlobalSection\n";
        solution << "EndGlobal";
        solution.close();
    }

    void visual_studio_project::save_targets_to_files(std::string_view root) {
        msvc_details::xml_save_map_to_file(vcxproj_map_, ".vcxproj", root);
        msvc_details::xml_save_map_to_file(vcxproj_filters_map_, ".vcxproj.filters", root);
    }
}
