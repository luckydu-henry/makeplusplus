#include <cstring>
#include <algorithm>
#include <format>
#include <ranges>
#include <iostream>
#include <fstream>
#include <filesystem>
#include <cstdlib>

#include "cpod.hpp"
#include "makeplusplus.hpp"

namespace makexx {

    //////////////////////////////////////////////////////////////
    ///             Header related functionalities             ///
    //////////////////////////////////////////////////////////////

    static void put_default_content(cpod::archive& arch) {
        static constexpr std::string_view generated_header_default =
            R"(//
// This header is generated by makeplusplus.
// All project must include this generated file, and all macros must be defined in this file either!
//

#include <cstdint>
#include <string>
#include <vector>
#include <list>
#include <deque>
#include <forward_list>
#include <map>
#include <unordered_map>
#include <set>
#include <unordered_set>

#define MXX_STD_CPP_LATEST   1
#define MXX_STD_CPP11        2
#define MXX_STD_CPP14        3
#define MXX_STD_CPP17        4
#define MXX_STD_CPP20        5
#define MXX_STD_CPP23        6
#define MXX_STD_CPP26        7

#define MXX_STD_C_LATEST     1
#define MXX_STD_C11          2
#define MXX_STD_C17          3
#define MXX_STD_C23          4

#define MXX_TARGET_TYPE_EXE  1
#define MXX_TARGET_TYPE_LIB  2
#define MXX_TARGET_TYPE_DLL  3

#define MXX_OPTIMIZATION_0   1
#define MXX_OPTIMIZATION_1   2
#define MXX_OPTIMIZATION_2   3
#define MXX_OPTIMIZATION_3   4

#define MXX_MSVC_SUBSYSTEM_CONSOLE 1
#define MXX_MSVC_SUBSYSTEM_WINDOW  2

#define PROJECT_NAME                           std::string              mxx_project_name
#define PROJECT_TARGETS                        std::vector<std::string> mxx_project_targets
#define PROJECT_CONFIGURATIONS                 std::vector<std::string> mxx_project_configurations

#define TARGET_SOURCES                         std::vector<std::string> mxx_target_sources
#define TARGET_HEADERS                         std::vector<std::string> mxx_target_headers
#define TARGET_DEPENDENCIES                    std::vector<std::string> mxx_target_dependencies
#define TARGET_DEFINES                         std::vector<std::string> mxx_target_defines
#define TARGET_EXTERNAL_LINKS                  std::vector<std::string> mxx_target_external_links
#define TARGET_EXTERNAL_LINK_DIRECTORIES       std::vector<std::string> mxx_target_external_link_directories  
#define TARGET_EXTERNAL_INCLUDE_DIRECTORIES    std::vector<std::string> mxx_target_external_include_directories

#define TARGET_BINARY_DIRECTORY                std::string              mxx_target_binary_directory
#define TARGET_INTERMEDIATE_DIRECTORY          std::string              mxx_target_intermediate_directory

#define TARGET_TYPE                            uint32_t                 mxx_target_type
#define TARGET_STD_CPP                         uint32_t                 mxx_target_std_cpp
#define TARGET_STD_C                           uint32_t                 mxx_target_std_c
#define TARGET_OPTIMIZATION                    uint32_t                 mxx_target_optimization

#define TARGET_MSVC_ICON                       std::string              mxx_target_msvc_icon
#define TARGET_MSVC_SUBSYSTEM                  uint32_t                 mxx_target_msvc_subsystem
)" ;
        arch.content().append(generated_header_default);
    }

    static std::string put_header_archive_to_buffer(const std::unordered_map<std::string_view, std::string>& defmap) {
        // Header file contains
        // 1. Your building system.
        // 2. Your executable path.
        // You don't need to define three above
        // Other macros defined in defmap would be added to the header with this three together.

        // I don't have plan to support mac or any apple platform (xcode project)
        // So basically besides on windows you are going to use visual studio
        // Makefile will work on all non window platforms.

        cpod::archive arch;
        put_default_content(arch);
        
        std::string current_path = std::filesystem::current_path().lexically_normal().generic_string() + "/";
        static constexpr std::string_view generated_plat_header =
            "#define MXX_EXE_PATH \"{:s}\"\n"
#ifdef _WIN32
            "#define MXX_SYSTEM_WINDOWS \"windows\"\n"
            "#define MXX_SYSTEM MXX_SYSTEM_WINDOWS\n"
#elif defined __linux__
            "#define MXX_SYSTEM_LINUX \"linux\"\n"
            "#define MXX_SYSTEM MXX_SYSTEM_LINUX\n"
#else
            "#define MXX_SYSTEM_REAL_UNIX \"unix\"\n"
            "#define MXX_SYSTEM MXX_SYSTEM_UNIX\n"
#endif
            ;
        arch.content().append(std::format(generated_plat_header, current_path));
        // Write all custom macros.
        for (auto& [key, val] : defmap) {
            arch.content().append(std::format("#define {:s} {:s}\n", key, val));
        }
        return arch.content();
    }

    static void get_header_archive_from_buffer(cpod::archive& arch, std::unordered_map<std::string_view, std::string>& defmap) {
        cpod::cpp_subset_compiler compiler(std::move(arch.content()));

        compiler.remove_comments(); compiler.src = compiler.out;             
        compiler.get_macro_define_map(defmap);
        arch.content() = std::move(compiler.src);

        for (auto& i : defmap) {
            cpod::cpp_subset_compiler::expand_macro_value(defmap, i.first);
        }
    }

    namespace msvc_details {

        static std::string           get_filter_path(std::string_view p) {
            std::string cache;
            for (const auto& i : p) {
                if (i == '/') {
                    cache.push_back('\\');
                } else {
                    cache.push_back(i);
                }
            }
            return cache;
        }

        static std::string           normalize_to_uppercase_mode(std::string_view mode) {
            std::string mode_upper_norm;
            std::ranges::transform(mode, std::back_inserter(mode_upper_norm), [](auto i) { return std::toupper(i); });
            return mode_upper_norm;
        }

        template <typename F>
        static std::string           convert_list_to_string(const std::vector<std::string>& links, std::string_view suffix, F op) {
            std::string result;
            for (auto& i : links) {
                result.append(op(i)).append(suffix).push_back(';');
            }
            result.pop_back();
            return result;
        }

        static void                  xml_save_map_to_file(std::unordered_map<std::string_view, xmloxx::tree>& map, std::string_view ext, std::string_view rootdir = "") {
            for (auto& [target_name, tree] : map) {
                std::ofstream map_file((std::filesystem::path(rootdir) / (std::string(target_name) + std::string(ext))).lexically_normal());
                auto s = tree.to_string();
                map_file.rdbuf()->sputn(s.data(), s.size());
            }
        }
        
        static std::string generate_guid() {
            std::srand(static_cast<unsigned int>(std::time(nullptr)));
            unsigned int r = std::rand();
            return std::format("{{{:08X}-{:04X}-{:04X}-{:04X}-{:08X}{:04X}}}",
                r % 0xFFFFFFFF, r % 0xFFFF, r % 0xFFFF, r % 0xFFFF,
                r % 0xFFFFFFFF, r % 0xFFFF);
        }

        static const char* get_project_type_string(target_types type) {
            static constexpr const char* types[] = { "",  "Application", "StaticLibrary", "DynamicLibrary" };
            return types[static_cast<std::uint32_t>(type)];
        }

        static const char* get_cpp_standard_string(target_cpp_standards standard) {
            static constexpr const char* standards[] = { "", "stdcpplatest", "stdcpp11", "stdcpp14", "stdcpp17", "stdcpp20", "stdcpp23", "stdcpp26" };
            return standards[static_cast<std::uint32_t>(standard)];
        }

        static const char* get_c_standard_string(target_c_standards standard) {
            static constexpr const char* standards[] = { "", "stdclatest", "stdc11", "stdc17", "stdc23" };
            return standards[static_cast<std::uint32_t>(standard)];
        }

        static const char* get_subsystem_string(target_msvc_subsystems sys) {
            static constexpr const char* systems[] = { "", "Console", "Windows" };
            return systems[static_cast<std::uint32_t>(sys)];
        }

        static const char* get_optimization_string(target_optimizations op) {
            static constexpr const char* optimizations[] = { "",  "Disabled", "MinSpace", "MaxSpeed", "Full" };
            return optimizations[static_cast<std::uint32_t>(op)];
        }

        static xmloxx::tree::iterator find_item_definition_group_element(xmloxx::tree& tree, std::string_view condition, std::string_view subrange) {
            return tree.find_first_child_with_name(
                tree.find_first_sibling_with_attribute(
                tree.find_nth_sibling(tree.begin() + 1, 12), "Condition", condition), subrange);
        }
        
        static auto  extract_config(std::string_view config) {
            std::size_t      split = config.find('_');
            std::string      mode(config.substr(split + 1));
            std::string      plat(config.substr(0, split));
            std::string      tag  = std::format("{:s}|{:s}", mode, plat);
            std::string      comb = std::format("'$(Configuration)|$(Platform)'=='{:s}'",tag);
            return std::make_tuple(mode, plat, tag, comb);
        }

        static void  generate_resource(std::string_view target_name, std::string_view iconname) {
            std::ofstream rc(std::string(target_name) + ".rc"), header(std::string(target_name) + ".resource.h");
            tiny_print(rc, R"(//
// Microsoft Visual C++ generated resource script.
//
#include "{0:s}.resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "{0:s}.resource.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#include ""winres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Icon
//

// Icon with lowest ID value placed first to ensure application icon
// remains consistent on all systems.
IDI_ICON1               ICON                    "{1:s}"

#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED)", target_name, iconname);

            tiny_print(header, R"(
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
//
#define IDI_ICON1                       101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
)");
            rc.close();
            header.close();
        }
    }

    /////////////////////////////////////////////////////////////
    //     Header and Sources only have little differences.    //
    /////////////////////////////////////////////////////////////
    
    static void target_attach_files_(xmloxx::tree& tree_filter, xmloxx::tree& tree_proj,
        const std::vector<std::string>& files, const std::string& filter_root, int type) {
        
        static const char* item_strings[] = { "", "ClInclude", "ClCompile", "Image", "ResourceCompile" };
        // Add filter to list.
        auto  item_group_file_filter = tree_filter.find_nth_sibling_with_name(tree_filter.begin() + 2, type); // The second child is the first item group.
        
        std::string absrt =  std::filesystem::absolute(std::filesystem::path(filter_root).lexically_normal()).generic_string();

#define GET_ABS_PATH(abspath)\
auto abspath = std::filesystem::absolute(std::filesystem::path(path).lexically_normal()).remove_filename().generic_string();\
abspath.erase(0, absrt.size());\
abspath = msvc_details::get_filter_path(abspath);\
if (!abspath.empty() && abspath.back() == '\\') { abspath.pop_back(); }
        
        for (auto& path : files) {
            GET_ABS_PATH(abspath)
            if (!abspath.empty()) {
                // vcxproj_filter_name_map_[abspath] = abspath;
                tree_filter.push_node("UniqueIdentifier",
                    tree_filter.push_node("Filter",tree_filter.begin() + 2)->push_attribute("Include", abspath))->text(msvc_details::generate_guid());
            }
        }
        
        for (auto& path : files) {
            tree_proj.push_node(item_strings[type], tree_proj.find_nth_sibling_with_name(tree_proj.begin() + 1, type))->push_attribute("Include", path);
        
            auto cl_item = tree_filter.push_node(item_strings[type], item_group_file_filter);
            cl_item->push_attribute("Include", path);
            
            GET_ABS_PATH(abspath)
            if (!abspath.empty()) {
                tree_filter.push_node("Filter", cl_item)->text(abspath);
            }
        }
    }

    static void target_set_item_definition_group_(xmloxx::tree& tree, std::string_view config, std::string_view scope, std::string_view elem, std::string_view value) {
        auto [mode, plat, tag, comb] = msvc_details::extract_config(config);
        tree.push_node(elem, msvc_details::find_item_definition_group_element(tree, comb, scope))->text(value);
    }

    static void target_append_property_group_(xmloxx::tree& tree, std::string_view condition, std::string_view scope, std::string_view value) {
        auto [mode, plat, tag, comb] = msvc_details::extract_config(condition);
        tree.push_node(scope,
            tree.find_first_sibling_with_attribute(
                tree.find_nth_sibling(tree.begin() + 1, 10), "Condition", comb))->text(value);
    }

    visual_studio_project::visual_studio_project(std::string_view sln_name, const std::vector<std::string>& configs)
    : solution_name_(sln_name), solution_configs_(configs) {}

    visual_studio_project& visual_studio_project::new_target(std::string_view target_name) {
        ////////////////////////////////////////////
        //                Filters                ///
        ////////////////////////////////////////////

        auto& tree_filter = vcxproj_filters_map_.try_emplace(target_name, "Project", 1 << 15).first->second;
        
        // Insert filter root project.
        tree_filter.begin()->push_attribute("ToolsVersion", "4.0")->push_attribute("xmlns", "http://schemas.microsoft.com/developer/msbuild/2003");

        tree_filter.push_node("Global", xmloxx::node_data::flag_comment);
        tree_filter.push_node("ItemGroup");

        tree_filter.push_node("Header", xmloxx::node_data::flag_comment);
        tree_filter.push_node("ItemGroup");

        tree_filter.push_node("Source", xmloxx::node_data::flag_comment);
        tree_filter.push_node("ItemGroup");

        tree_filter.push_node("Icon", xmloxx::node_data::flag_comment);
        tree_filter.push_node("ItemGroup");

        tree_filter.push_node("Resource", xmloxx::node_data::flag_comment);
        tree_filter.push_node("ItemGroup");
        
        ////////////////////////////////////////////
        //                Project                ///
        ////////////////////////////////////////////
        vcxproj_guid_map_[target_name] = msvc_details::generate_guid();
        auto& tree_proj = vcxproj_map_.try_emplace(target_name, "Project", 1 << 15).first->second;
        
        tree_proj.begin()->push_attribute("DefaultTargets", "Build")->push_attribute("xmlns", "http://schemas.microsoft.com/developer/msbuild/2003");

        // Insert ItemGroup project configurations
        auto item_group_project_config = tree_proj.push_node("ItemGroup")->push_attribute("Label", "ProjectConfigurations");
        for (std::string_view config : solution_configs_) {
            auto[mode, plat, tag, comb] = msvc_details::extract_config(config);
            auto project_config = tree_proj.push_node("ProjectConfiguration", item_group_project_config)->push_attribute("Include", tag);
            tree_proj.push_node("Configuration", project_config)->text(mode);
            tree_proj.push_node("Platform"     , project_config)->text(plat);
        }
        
        // Insert global configurations
        auto property_group_globals = tree_proj.push_node("PropertyGroup")->push_attribute("Label", "Globals");
        tree_proj.push_node("ProjectGuid"  , property_group_globals)->text(vcxproj_guid_map_[target_name]);
        tree_proj.push_node("RootNamespace", property_group_globals)->text(target_name);
        tree_proj.push_node("ProjectName"  , property_group_globals)->text(target_name);
        tree_proj.push_node("WindowsTargetPlatformVersion", property_group_globals)->text("10.0");
        
        
        // Import compile properties
        tree_proj.push_node("Import")->push_attribute("Project", "$(VCTargetsPath)\\Microsoft.Cpp.Default.props");
        
        // Insert configuration.
        for (std::string_view config : solution_configs_) {
            auto[mode, plat, tag, comb] = msvc_details::extract_config(config);
            std::string mode_upper_norm = msvc_details::normalize_to_uppercase_mode(mode);
        
            auto project_group_cond_config = tree_proj.push_node("PropertyGroup")
            ->push_attribute("Condition", comb)->push_attribute("Label", "Configuration");
        
            tree_proj.push_node("ConfigurationType", project_group_cond_config)->text("Application");
            tree_proj.push_node("PlatformToolset",   project_group_cond_config)->text("v143");
            tree_proj.push_node("CharacterSet",      project_group_cond_config)->text("Unicode");
            tree_proj.push_node("UseDebugLibraries", project_group_cond_config)->text(mode_upper_norm == "DEBUG" ? "true" : "false");
        }
        tree_proj.push_node("Import")->push_attribute("Project", "$(VCTargetsPath)\\Microsoft.Cpp.props");
        
        // Import extension property list.
        tree_proj.push_node("ImportGroup")->push_attribute("Label", "ExtensionSettings");
        tree_proj.push_node("ImportGroup")->push_attribute("Label", "Shared");
        
        // Use for loop to set all config related properties.
        for (std::string_view config : solution_configs_) {
            auto[mode, plat, tag, comb] = msvc_details::extract_config(config);
            
            auto import_group_property_sheets_config = tree_proj.push_node("ImportGroup")
            ->push_attribute("Label", "PropertySheets")->push_attribute("Condition", comb);
        
            tree_proj.push_node("Import", import_group_property_sheets_config)
            ->push_attribute("Project", "$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props")
            ->push_attribute("Condition", "exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')")
            ->push_attribute("Label", "LocalAppDataPlatform");
        }
        
        tree_proj.push_node("PropertyGroup")->push_attribute("Label", "UserMacros");
        
        // For OutDir and IntDir.
        for (std::string_view config : solution_configs_) {
            auto[mode, plat, tag, comb] = msvc_details::extract_config(config);
            tree_proj.push_node("PropertyGroup")->push_attribute("Condition", comb);
        }
        
        // Insert item definitions.
        for (std::string_view config : solution_configs_) {
            auto[mode, plat, tag, comb] = msvc_details::extract_config(config);
            std::string mode_upper_norm = msvc_details::normalize_to_uppercase_mode(mode);
            auto  idg = tree_proj.push_node("ItemDefinitionGroup")->push_attribute("Condition", comb);
            
            auto  com = tree_proj.push_node("ClCompile", idg);
            tree_proj.push_node("WarningLevel",    com)->text("Level3");
            tree_proj.push_node("SDLCheck",        com)->text("true");
            tree_proj.push_node("ConformanceMode", com)->text("true");
        
            auto  lnk = tree_proj.push_node("Link", idg);
            tree_proj.push_node("GenerateDebugInformation", lnk)->text("true");
            
            // Release specific defines
            if (mode_upper_norm != "DEBUG") {
                tree_proj.push_node("FunctionLevelLinking", com)->text("true");
                tree_proj.push_node("IntrinsicFunctions",   com)->text("true");
                tree_proj.push_node("EnableCOMDATFolding", lnk)->text("true");
                tree_proj.push_node("OptimizeReferences",  lnk)->text("true");
            }
        }
        
        // include item group sequence 'project configuration''include' 'compile' 'icon' ‘resource’ 'dependencies'
        tree_proj.push_node("Include items", xmloxx::node_data::flag_comment);
        tree_proj.push_node("ItemGroup");
        
        tree_proj.push_node("Source items", xmloxx::node_data::flag_comment);
        tree_proj.push_node("ItemGroup");
        
        tree_proj.push_node("Import")      ->push_attribute("Project", "$(VCTargetsPath)\\Microsoft.Cpp.targets");
        tree_proj.push_node("ImportGroup") ->push_attribute("Label", "ExtensionTargets");
        
        tree_proj.push_node("Icon Item", xmloxx::node_data::flag_comment);
        tree_proj.push_node("ItemGroup");
        
        tree_proj.push_node("Resource Item", xmloxx::node_data::flag_comment);
        tree_proj.push_node("ItemGroup");
        
        tree_proj.push_node("Dependency Item", xmloxx::node_data::flag_comment);
        tree_proj.push_node("ItemGroup");
        
        return *this;
    }

    visual_studio_project& visual_studio_project::target_headers(std::string_view target_name,
        const std::vector<std::string>& headers, const std::string& filter) {
        target_attach_files_(vcxproj_filters_map_.at(target_name), vcxproj_map_.at(target_name), headers, filter, Attach_Headers);
        return *this;        
    }
    
    visual_studio_project& visual_studio_project::target_sources(std::string_view target_name,
        const std::vector<std::string>& sources, const std::string& filter) {
        target_attach_files_(vcxproj_filters_map_.at(target_name), vcxproj_map_.at(target_name), sources, filter, Attach_Sources);
        return *this;
    }
    
    visual_studio_project& visual_studio_project::target_msvc_icon(std::string_view target_name, std::string_view resource) {
        msvc_details::generate_resource(target_name, resource);
        target_attach_files_(vcxproj_filters_map_.at(target_name), vcxproj_map_.at(target_name),
            {std::filesystem::absolute(resource).generic_string()}, "./", Attach_Icon);
        target_attach_files_(vcxproj_filters_map_.at(target_name), vcxproj_map_.at(target_name),
            {std::filesystem::absolute(std::string(target_name) + ".rc").generic_string()}, "./", Attach_Resource);
        return *this;
    }

    visual_studio_project& visual_studio_project::target_dependencies(std::string_view target_name, const std::vector<std::string>& dependencies) {
        auto& tree_proj    = vcxproj_map_.at(target_name);
        auto  item_group   = tree_proj.find_nth_sibling_with_name(tree_proj.begin() + 1, Attach_Dependency);
        for (std::string_view dependency : dependencies) {
            tree_proj.push_node("Project",
                tree_proj.push_node("ProjectReference", item_group)->push_attribute("Include",  (std::string(dependency) + ".vcxproj")))
            ->text(vcxproj_guid_map_[dependency]);
        }
        return *this;
    }
    
    
    visual_studio_project& visual_studio_project::target_type(std::string_view target_name, target_types type) {
        auto& tree_proj       = vcxproj_map_.at(target_name);
        auto  property_group  = tree_proj.find_nth_sibling(tree_proj.begin() + 1, 3);
        for (auto& config : solution_configs_) {
            tree_proj.find_first_child(property_group)->text(msvc_details::get_project_type_string(type));
            property_group = tree_proj.find_first_sibling(property_group);
        }
        return *this;
    }

    visual_studio_project& visual_studio_project::target_std_cpp(std::string_view target_name,
        target_cpp_standards  version) {
        for (auto& config : solution_configs_) {
            target_set_item_definition_group_(vcxproj_map_.at(target_name), config,
                "ClCompile", "LanguageStandard", msvc_details::get_cpp_standard_string(version));
        }
        return *this;
    }
    
    visual_studio_project& visual_studio_project::target_std_c(std::string_view target_name,
        target_c_standards version) {
        for (auto& config : solution_configs_) {
            target_set_item_definition_group_(vcxproj_map_.at(target_name), config,
                "ClCompile", "LanguageStandard_C", msvc_details::get_c_standard_string(version));
        }
        return *this;
    }
    
    visual_studio_project& visual_studio_project::target_msvc_subsystem(std::string_view target_name,
        target_msvc_subsystems sys) {
        for (auto& config : solution_configs_) {
            target_set_item_definition_group_(vcxproj_map_.at(target_name), config,
                "Link", "SubSystem", msvc_details::get_subsystem_string(sys));
        }
        return *this;
    }
    
    
    visual_studio_project& visual_studio_project::target_optimization(std::string_view target_name, target_optimizations op, std::string_view config) {
        target_set_item_definition_group_(vcxproj_map_.at(target_name), config, "ClCompile", "Optimization", msvc_details::get_optimization_string(op));
        return *this;
    }
    
    visual_studio_project& visual_studio_project::target_defines(std::string_view target_name, const std::vector<std::string>& defines, std::string_view config) {
        auto nmode = msvc_details::normalize_to_uppercase_mode(std::get<0>(msvc_details::extract_config(config)));
        std::string_view mac = nmode == "DEBUG" ? "_DEBUG" : "NDEBUG";
        target_set_item_definition_group_(vcxproj_map_.at(target_name), config,
            "ClCompile", "PreprocessorDefinitions", std::format("{:s};{:s};%(PreprocessorDefinitions)",
                msvc_details::convert_list_to_string(defines, "", [](const std::string& i) { return i; }), mac));
        return *this;
    }
    
    visual_studio_project& visual_studio_project::target_external_link_directories(std::string_view target_name,
        const std::vector<std::string>& dirs) {
        for (auto& config : solution_configs_) {
            target_set_item_definition_group_(vcxproj_map_.at(target_name), config,
        "Link", "AdditionalLibraryDirectories",
        msvc_details::convert_list_to_string(dirs, "", [](const std::string& i) {
                     return std::filesystem::path(i).lexically_normal().generic_string();
            }));
        }
        return *this;
    }
    
    visual_studio_project& visual_studio_project::target_external_include_directories(std::string_view target_name,
        const std::vector<std::string>& dirs) {
        for (auto& config : solution_configs_) {
            target_set_item_definition_group_(vcxproj_map_.at(target_name), config,
        "ClCompile", "AdditionalIncludeDirectories",
        msvc_details::convert_list_to_string(dirs, "", [](const std::string& i) {
                     return std::filesystem::path(i).lexically_normal().generic_string();
            }));
        }
        return *this;
    }
    
    visual_studio_project& visual_studio_project::target_external_links(std::string_view target_name, const std::vector<std::string>& links, std::string_view config) {
        target_set_item_definition_group_(vcxproj_map_.at(target_name), config,
            "Link", "AdditionalDependencies",
            std::format("{:s};%(AdditionalDependencies)", msvc_details::convert_list_to_string(links, ".lib",
                 [](const std::string& i) { return i; })));
        return *this;
    }
    
    visual_studio_project& visual_studio_project::target_binary_directory(std::string_view target_name, std::string_view dir, std::string_view config) {
        target_append_property_group_(vcxproj_map_.at(target_name), config, "OutDir", dir);
        return *this;
    }
    
    visual_studio_project& visual_studio_project::target_intermediate_directory(std::string_view target_name, std::string_view dir, std::string_view config) {
        target_append_property_group_(vcxproj_map_.at(target_name), config, "IntDir", dir);
        return *this;
    }

    void visual_studio_project::save_project_to_file(std::string_view root) {
        // Solution file generator generates only the necessary part
        // Won't contain visual studio version.
        std::ofstream solution(std::filesystem::path(root) / (solution_name_ + ".sln"));
        tiny_print(solution, "Microsoft Visual Studio Solution File, Format Version 12.00\n");
        std::string sln_guid = msvc_details::generate_guid();
        for (const auto target : vcxproj_guid_map_ | std::views::keys) {
            tiny_print(solution, "Project(\"{0:s}\") = \"{1:s}\", \"{1:s}.vcxproj\", \"{2:s}\"\nEndProject\n", sln_guid, target, vcxproj_guid_map_[target]);
        }
        tiny_print(solution, "Global\n    GlobalSection(SolutionConfigurationPlatforms) = preSolution\n");
        for (auto& config : solution_configs_) {
            auto[mode, plat, tag, comb] = msvc_details::extract_config(config);
            tiny_print(solution, "        {0:s} = {0:s}\n", tag);
        }
        tiny_print(solution, "    EndGlobalSection\n    GlobalSection(ProjectConfigurationPlatforms) = postSolution\n");
        for (auto& guid : vcxproj_guid_map_ | std::views::values) {
            for (auto& config : solution_configs_) {
                auto[mode, plat, tag, comb] = msvc_details::extract_config(config);
                tiny_print(solution, "        {0:s}.{1:s}.ActiveCfg = {1:s}\n        {0:s}.{1:s}.Build.0 = {1:s}\n", guid, tag);
            }
        }
        tiny_print(solution, "    EndGlobalSection\n	 GlobalSection(SolutionProperties) = preSolution\n        HideSolutionNode = FALSE\n    EndGlobalSection\nEndGlobal");
        solution.close();
    }

    void visual_studio_project::save_targets_to_files(std::string_view root) {
        msvc_details::xml_save_map_to_file(vcxproj_map_, ".vcxproj", root);
        msvc_details::xml_save_map_to_file(vcxproj_filters_map_, ".vcxproj.filters", root);
    }

    ////////////////////////////////////////////////////////////////////////////////////
    ///                                Real Application                              ///
    ////////////////////////////////////////////////////////////////////////////////////

    void make_application::generate_header_() {
        std::ofstream header("makexx.generated.hpp");
        tiny_print(header, "{:s}", put_header_archive_to_buffer({
            {"MXX_PROJECT_ROOT", std::format("\"{:s}/\"", std::filesystem::current_path().parent_path().generic_string())}
        }));
        header.close();
        tiny_print(std::cout, "Header generated!\n");
    }

    void make_application::generate_project_() {
        if (argc_ < 3) {
            tiny_print(std::cout, "Error, must have project name argument!\n");
            return;
        }
        std::string_view project_name = argv_[2];
        if (!std::filesystem::exists("makexx.generated.hpp")) {
            generate_header_();
        }
        std::ofstream project(std::format("../{:s}.make.hpp", project_name));
        tiny_print(project,
            "#include \"{:s}/makexx.generated.hpp\"\n\n"
            "// Makeplusplus project!\n"
            "PROJECT_NAME = \"{:s}\";\n"
            "PROJECT_TARGETS = {{\"\"}};\n"
            "PROJECT_CONFIGURATIONS = {{\"\"}};\n\n"
            "#pragma target_definitions\n"
            , std::filesystem::current_path().filename().generic_string(), project_name);
        project.close();
        tiny_print(std::cout, "Project description \"{:s}\" has been written to \"{:s}\"\n", project_name, std::filesystem::current_path().generic_string());
    }

    void make_application::read_current_definition_map_() {
        std::ifstream     header("./makexx.generated.hpp");
        std::string       str;
        std::copy(std::istreambuf_iterator<char>(header), std::istreambuf_iterator<char>(), std::back_inserter(str));
        static cpod::archive static_archive(std::move(str));
        get_header_archive_from_buffer(static_archive, definition_map_);
    }

    void make_application::read_source_and_split_targets_() {
        read_current_definition_map_();
        
        if (argc_ < 3) {
            tiny_print(std::cout, "Error, must have project description path argument!\n");
            return;
        }

        std::string_view    project_desc_path = argv_[2];
        std::ifstream       ifs(project_desc_path.data());

        if (!ifs.good()) {
            tiny_print(std::cout, "Error, invalid description path!\n");
            return;
        }

        std::string   source_cache;
        bool          before_first_namespace = true;
        std::size_t   scope_count = 0;
        std::string   current_scope_name;

        // Split all targets.
        for (std::string line_cache; std::getline(ifs, line_cache);) {
            if (before_first_namespace) {
                if (line_cache == "#pragma target_definitions") {
                    before_first_namespace = false;
                    mxx_project_source_fields_["project_scope"] = source_cache;
                    source_cache.clear();
                }
                else {
                    if (line_cache.find("#include") == std::string::npos) {
                        source_cache.append(line_cache);
                        source_cache.push_back('\n');
                    }
                }
            }
            else {
                if (auto b = line_cache.find("namespace"); b != std::string::npos) {
                    // The first one.
                    std::size_t end = line_cache.find(' ', b + 10);
                    std::string scope_name_cache = line_cache.substr(b + 10, end - b - 10);
                    if (scope_count == 0) {
                        current_scope_name = scope_name_cache;
                    } else {
                        source_cache.append(std::format("#pragma target_config {:s}\n", scope_name_cache));
                    }
                    ++scope_count;
                }
                else {
                    if (line_cache.find('{') != std::string::npos) {
                        ++scope_count;
                    }
                    if (line_cache.find('}') != std::string::npos) {
                        if (scope_count == 1) {
                            mxx_project_source_fields_[current_scope_name] = source_cache;
                            source_cache.clear();
                        }
                        --scope_count;
                    }
                    std::erase_if(line_cache, [](auto& it){ return std::isspace(it) && std::isspace((&it)[1]); });
                    if (line_cache != " }") {
                        source_cache.append(line_cache);
                        source_cache.push_back('\n');
                    }
                }
            }
        }
        
        // Read project scope data.
        cpod::archive current_archive(mxx_project_source_fields_["project_scope"]);
        current_archive.compile_content_default(definition_map_);
            
#define FIND_AND_GET_PROPERTY(fn) do { \
if (auto it = current_archive.find_variable_begin<decltype(fn)>(#fn); it != current_archive.content_end()) {\
    cpod::serializer<decltype(fn)>{}(it, fn, 0); \
}} while (false)

        FIND_AND_GET_PROPERTY(mxx_project_name);
        FIND_AND_GET_PROPERTY(mxx_project_targets);
        FIND_AND_GET_PROPERTY(mxx_project_configurations);
    }

    namespace generator_details {
        template <class Ty>
        static constexpr Ty no_operation(const Ty& v) {
            return v;
        }

        template <class E>
        static constexpr E  enum_convert(auto e) {
            return static_cast<E>(e);
        }

        static std::vector<std::string> unwrap_shrunk_path(const std::string& path) {
            // Current only support **.ext and *.ext !
            auto absp = std::filesystem::absolute(path);
            auto ext = absp.extension();
            std::vector<std::string> result_paths;
    
            if (path.find("**") != std::string::npos) {
                for (auto p = std::filesystem::recursive_directory_iterator(absp.parent_path());
                    p != std::filesystem::recursive_directory_iterator(); ++p) {
                    if (p->path().extension() == ext) {
                        result_paths.emplace_back(p->path().generic_string());
                    }
                }
                return result_paths;
            }
            if (path.find('*') != std::string::npos) {
                for (auto p = std::filesystem::directory_iterator(absp.parent_path());
                    p != std::filesystem::directory_iterator(); ++p) {
                    if (p->path().extension() == ext) {
                        result_paths.emplace_back(p->path().generic_string());
                    }
                }
                return result_paths;
            }
            return {path};
        }

        static std::vector<std::string> unwrap_shrunk_paths(const std::vector<std::string>& paths) {
            std::vector<std::string> result;
            for (const auto& path : paths) {
                std::vector<std::string> unwripped = unwrap_shrunk_path(path);
                result.insert(result.end(), unwripped.begin(), unwripped.end());
            }
            return result;
        }
    }

    ////////////////////////////////////////////////////////////
    //            Also belongs to generator                   //
    ////////////////////////////////////////////////////////////
    
    static std::string fix_path_(std::string_view path, const std::string& ir) {
        std::string root = ir;
        std::erase(root, '\"');
        return (std::filesystem::path(root) / path).lexically_normal().generic_string();
    }

    std::vector<std::string> fix_paths_(std::vector<std::string>& paths, const std::string& ir) {
        for (auto& path : paths) {
            path = fix_path_(path, ir);
        }
        return generator_details::unwrap_shrunk_paths(paths);
    }
    
    void makexx::make_application::read_target_and_generate_vs_project_(const std::string& target, const std::string& source, visual_studio_project& vssln) {
        std::stringstream strbuf;
        tiny_print(strbuf, "{:s}\n#pragma target_config end", source);

#define FIND_AND_SET_PROPERTY(fn, hd, ...) do { \
if (auto it = current_archive.find_variable_begin<decltype(mxx_##fn)>("mxx_"#fn); it != current_archive.content_end()) {\
    cpod::serializer<decltype(mxx_##fn)>{}(it, mxx_##fn, 0); \
    auto hd_var = hd(mxx_##fn);                          \
    vssln.fn(target, hd_var,##__VA_ARGS__);           \
}} while (false)


#define FIND_AND_SET_PROPERTY_EX(fn, hd, q, ...) do { \
if (auto it = current_archive.find_variable_begin<decltype(mxx_##fn)>("mxx_"#fn); it != current_archive.content_end()) {\
cpod::serializer<decltype(mxx_##fn)>{}(it, mxx_##fn, 0); \
auto hd_var = hd(mxx_##fn, q);                          \
vssln.fn(target, hd_var,##__VA_ARGS__);           \
}} while (false)
        
        std::string      splited_source;
        std::size_t      config_count = 0;
        std::string      current_config;
        
        for (std::string line_cache; std::getline(strbuf, line_cache);) {
            if (std::memcmp(line_cache.c_str(), "#pragma target_config ", 22) == 0) {
                cpod::archive    current_archive(splited_source);
                current_archive.compile_content_default(definition_map_);
                if (config_count == 0) {
                    // Variables needed to be loaded.
                    std::vector<std::string> mxx_target_headers;
                    std::vector<std::string> mxx_target_sources;
                    std::vector<std::string> mxx_target_dependencies;
                    std::vector<std::string> mxx_target_external_link_directories;
                    std::vector<std::string> mxx_target_external_include_directories;

                    std::string              mxx_target_msvc_icon;
                    std::uint32_t            mxx_target_type;
                    std::uint32_t            mxx_target_std_cpp;
                    std::uint32_t            mxx_target_std_c;
                    std::uint32_t            mxx_target_msvc_subsystem;

                    auto filter_root = fix_path_("", definition_map_["MXX_PROJECT_ROOT"]);
                    
                    FIND_AND_SET_PROPERTY_EX(target_sources,                        fix_paths_, definition_map_["MXX_PROJECT_ROOT"], filter_root);
                    FIND_AND_SET_PROPERTY_EX(target_headers,                        fix_paths_, definition_map_["MXX_PROJECT_ROOT"], filter_root);
                    FIND_AND_SET_PROPERTY_EX(target_msvc_icon,                      fix_path_ , definition_map_["MXX_PROJECT_ROOT"]);
                    FIND_AND_SET_PROPERTY   (target_dependencies,                   generator_details::no_operation);
                    FIND_AND_SET_PROPERTY   (target_type,                           generator_details::enum_convert<target_types>);
                    FIND_AND_SET_PROPERTY   (target_std_cpp,                        generator_details::enum_convert<target_cpp_standards>);
                    FIND_AND_SET_PROPERTY   (target_std_c,                          generator_details::enum_convert<target_c_standards>);
                    FIND_AND_SET_PROPERTY   (target_msvc_subsystem,                 generator_details::enum_convert<target_msvc_subsystems>);
                    FIND_AND_SET_PROPERTY_EX(target_external_link_directories,      fix_paths_, definition_map_["MXX_PROJECT_ROOT"]);
                    FIND_AND_SET_PROPERTY_EX(target_external_include_directories,   fix_paths_, definition_map_["MXX_PROJECT_ROOT"]);
                    ++config_count;
                }
                else {
                    // Means the config we use is not available.
                    if (std::ranges::find(mxx_project_configurations, current_config) == mxx_project_configurations.end()) {
                        tiny_print(std::cout, "You are defining a configuration namespace that has not declared in PROJECT_CONFIGURATIONS!\n");
                    }
                    
                    std::vector<std::string> mxx_target_defines;
                    std::vector<std::string> mxx_target_external_links;
                    std::string              mxx_target_binary_directory;
                    std::string              mxx_target_intermediate_directory;
                    std::uint32_t            mxx_target_optimization;
                    
                    FIND_AND_SET_PROPERTY(target_optimization,            generator_details::enum_convert<target_optimizations>, current_config);
                    FIND_AND_SET_PROPERTY(target_defines,                 generator_details::no_operation,                       current_config);
                    FIND_AND_SET_PROPERTY(target_external_links,          generator_details::no_operation,                       current_config);
                    FIND_AND_SET_PROPERTY_EX(target_intermediate_directory,  fix_path_, definition_map_["MXX_PROJECT_ROOT"],     current_config);
                    FIND_AND_SET_PROPERTY_EX(target_binary_directory,        fix_path_, definition_map_["MXX_PROJECT_ROOT"],     current_config);
                    ++config_count;
                }
                splited_source.clear();
                current_config = line_cache.substr(22);
            } else {
                splited_source.append(line_cache);
                splited_source.push_back('\n');
            }
        }
        
    }

    void make_application::generate_actual_visual_studio_project_() {
        read_source_and_split_targets_();
        tiny_print(std::cout,
            "----------------------------------------------------------------------------------------------\n"
        "Makepluplus project descriptor {:s} parsing complete!\n"
        "Generating project using \"Visual Studio Generator\"!\n", argv_[2]);
        
        visual_studio_project vssln(mxx_project_name, mxx_project_configurations);
    
        for (auto& target : mxx_project_targets) {
            vssln.new_target(target);
        }
        
        for (auto& target : mxx_project_targets) {
            auto& source = mxx_project_source_fields_[target];
            read_target_and_generate_vs_project_(target, source, vssln);
            tiny_print(std::cout, "VC++ Project {:s} generated!\n", target);
        }
    
        std::filesystem::create_directory(mxx_project_name);
        vssln.save_targets_to_files(mxx_project_name);
        vssln.save_project_to_file(mxx_project_name);
    
        tiny_print(std::cout, "Visual Studio Solution {:s} generated!\n"
            "----------------------------------------------------------------------------------------------\n",mxx_project_name);
    }

    make_application::make_application(int argc, char** argv) : argc_(argc), argv_(argv) {
    }

    int make_application::operator()() {
        using namespace std::string_view_literals;
        if (argc_ == 1) {
            tiny_print(std::cout, s_hello_message);
            return 0;
        }
        // Generate project
        if      ("-gh"sv    == argv_[1])    { generate_header_(); }
        else if ("-gp"sv    == argv_[1])    { generate_project_(); }
        else if ("-gv"sv    == argv_[1])    { 
#ifdef _MSC_VER    
            generate_actual_visual_studio_project_(); 
#else
            tiny_print(std::cout, "This is not a MSVC generate program, use -gm for makefile generation!\n");
#endif
        }
        else if ("-h"sv     == argv_[1]  ||
                 "--help"sv == argv_[1])    {
            tiny_print(std::cout, "{:s}\n", s_help_message);
        }
        return 0;
    }
}
