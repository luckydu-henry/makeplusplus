#include <algorithm>
#include <random>
#include <format>
#include <ranges>
#include <iostream>
#include <fstream>
#include <filesystem>

#include "tinyxml2/tinyxml2.h"
#include "cpod.hpp"
#include "makeplusplus.hpp"

namespace makexx {

    //////////////////////////////////////////////////////////////
    ///             Header related functionalities             ///
    //////////////////////////////////////////////////////////////

    void put_default_content(cpod::archive& arch) {
        arch << cpod::com(" This header is generated by makeplusplus.")
             << cpod::com(" All project must include this generated file, and all macros must be defined in this file either!") << '\n';
        static constexpr std::string_view header_names[] = {
            "cstdint", "string", "vector", "list", "deque", "forward_list", "map", "unordered_map",
            "set", "unordered_set"
        };
        for (auto& i : header_names) {
            arch << cpod::txt("#include <{:s}>\n", i);
        }
        arch << '\n';

        // Define CPP_STD enums.
        arch << cpod::def("MXX_STD_CPP_LATEST", "1");
        arch << cpod::def("MXX_STD_CPP11", "2");
        arch << cpod::def("MXX_STD_CPP14", "3");
        arch << cpod::def("MXX_STD_CPP17", "4");
        arch << cpod::def("MXX_STD_CPP20", "5");
        arch << cpod::def("MXX_STD_CPP23", "6");
        arch << cpod::def("MXX_STD_CPP26", "7") << '\n';

        // Define C_STD enums.
        arch << cpod::def("MXX_STD_C_LATEST", "1");
        arch << cpod::def("MXX_STD_C11", "2");
        arch << cpod::def("MXX_STD_C17", "3");
        arch << cpod::def("MXX_STD_C23", "4") << '\n';

        // Define target type enums.
        arch << cpod::def("MXX_TARGET_TYPE_EXE", "1");
        arch << cpod::def("MXX_TARGET_TYPE_LIB", "2");
        arch << cpod::def("MXX_TARGET_TYPE_DLL", "3") << '\n';

        // Define optimization level enums
        arch << cpod::def("MXX_OPTIMIZATION_0", "1");
        arch << cpod::def("MXX_OPTIMIZATION_1", "2");
        arch << cpod::def("MXX_OPTIMIZATION_2", "3");
        arch << cpod::def("MXX_OPTIMIZATION_3", "4") << '\n';

        arch << cpod::def("MXX_MSVC_SUBSYSTEM_CONSOLE", "1");
        arch << cpod::def("MXX_MSVC_SUBSYSTEM_WINDOW",  "2") << '\n';

#define TYPE_AND_VAR_STRING(type, var) #type" "#var
        // Project define macros.
        arch << cpod::def("PROJECT_NAME",            TYPE_AND_VAR_STRING(std::string              , mxx_project_name));
        arch << cpod::def("PROJECT_TARGETS",         TYPE_AND_VAR_STRING(std::vector<std::string> , mxx_project_targets));
        arch << cpod::def("PROJECT_CONFIGURATIONS",  TYPE_AND_VAR_STRING(std::vector<std::string> , mxx_project_configurations)) << '\n';

        // Target define macros.
        arch << cpod::def("TARGET_SOURCES",                          TYPE_AND_VAR_STRING(std::vector<std::string> , mxx_target_sources));
        arch << cpod::def("TARGET_HEADERS",                          TYPE_AND_VAR_STRING(std::vector<std::string> , mxx_target_headers));
        arch << cpod::def("TARGET_DEPENDENCIES",                     TYPE_AND_VAR_STRING(std::vector<std::string> , mxx_target_dependencies));
        arch << cpod::def("TARGET_DEFINES",                          TYPE_AND_VAR_STRING(std::vector<std::string> , mxx_target_defines));
        arch << cpod::def("TARGET_EXTERNAL_LINKS",                   TYPE_AND_VAR_STRING(std::vector<std::string> , mxx_target_external_links));
        arch << cpod::def("TARGET_EXTERNAL_LINK_DIRECTORIES",        TYPE_AND_VAR_STRING(std::vector<std::string> , mxx_target_external_link_directories));
        arch << cpod::def("TARGET_EXTERNAL_INCLUDE_DIRECTORIES",     TYPE_AND_VAR_STRING(std::vector<std::string> , mxx_target_external_include_directories)) << '\n';
        
        arch << cpod::def("TARGET_BINARY_DIRECTORY",      TYPE_AND_VAR_STRING(std::string , mxx_target_binary_directory));
        arch << cpod::def("TARGET_INTERMEDIATE_DIRECTORY",TYPE_AND_VAR_STRING(std::string , mxx_target_intermediate_directory)) << '\n';

        arch << cpod::def("TARGET_TYPE" ,           TYPE_AND_VAR_STRING(uint32_t , mxx_target_type));
        arch << cpod::def("TARGET_STD_CPP",         TYPE_AND_VAR_STRING(uint32_t , mxx_target_std_cpp));
        arch << cpod::def("TARGET_STD_C",           TYPE_AND_VAR_STRING(uint32_t , mxx_target_std_c));
        arch << cpod::def("TARGET_OPTIMIZATION",    TYPE_AND_VAR_STRING(uint32_t , mxx_target_optimization)) << '\n';
        
        arch << cpod::def("TARGET_MSVC_ICON",       TYPE_AND_VAR_STRING(std::string , mxx_target_msvc_icon));
        arch << cpod::def("TARGET_MSVC_SUBSYSTEM",  TYPE_AND_VAR_STRING(uint32_t    , mxx_target_msvc_subsystem)) << '\n';

#undef TYPE_AND_VAR_STRING
    }

    std::string put_header_archive_to_buffer(const std::unordered_map<std::string_view, std::string>& defmap) {
        // Header file contains
        // 1. Your building system.
        // 2. Your executable path.
        // You don't need to define three above
        // Other macros defined in defmap would be added to the header with this three together.

        // I don't have plan to support mac or any apple platform (xcode project)
        // So basically besides on windows you are going to use visual studio
        // Makefile will work on all non window platforms.

        cpod::archive arch;
        put_default_content(arch);
        
        std::string current_path = std::filesystem::current_path().lexically_normal().generic_string() + "/";
        arch << cpod::def("MXX_EXE_PATH", std::format("\"{:s}\"", current_path));
#ifdef _WIN32
        arch << cpod::def("MXX_SYSTEM_WINDOWS", "\"windows\"");
        arch << cpod::def("MXX_SYSTEM", "MXX_SYSTEM_WINDOWS");
#elif defined __linux__
        arch << cpod::def("MXX_SYSTEM_LINUX", "\"linux\"");
        arch << cpod::def("MXX_SYSTEM", "MXX_SYSTEM_LINUX");
#else
        arch << cpod::def("MXX_SYSTEM_REAL_UNIX", "\"unix\"");
        arch << cpod::def("MXX_SYSTEM", "MXX_SYSTEM_UNIX");
#endif
        // Write all custom macros.
        for (auto& [key, val] : defmap) {
            arch << cpod::def(key, val);
        }
        return arch.content();
    }

    void get_header_archive_from_buffer(cpod::archive& arch, std::unordered_map<std::string_view, std::string>& defmap) {
        cpod::cpp_subset_compiler compiler(std::move(arch.content()));

        compiler.remove_comments(); compiler.src = compiler.out;             
        compiler.get_macro_define_map(defmap);
        arch.content() = std::move(compiler.src);

        for (auto& i : defmap) {
            cpod::cpp_subset_compiler::expand_macro_value(defmap, i.first);
        }
    }

    namespace msvc_details {

        static std::string           get_filter_path(std::string_view p) {
            std::string cache;
            for (const auto& i : p) {
                if (i == '/') {
                    cache.push_back('\\');
                } else {
                    cache.push_back(i);
                }
            }
            return cache;
        }

        static std::string           normalize_to_uppercase_mode(std::string_view mode) {
            std::string mode_upper_norm;
            std::ranges::transform(mode, std::back_inserter(mode_upper_norm), [](auto i) { return std::toupper(i); });
            return mode_upper_norm;
        }

        template <typename F>
        static std::string           convert_list_to_string(const std::vector<std::string>& links, std::string_view suffix, F op) {
            std::string result;
            for (auto& i : links) {
                result.append(op(i)).append(suffix).push_back(';');
            }
            result.pop_back();
            return result;
        }
        
        static msvc_xml::element* xml_find_child_with_index(std::string_view name, msvc_xml::element* root, std::size_t n = 0) {
            msvc_xml::element* element = root->begin_child_elem(name.data());
            for (std::size_t i = 0; i != n; ++i) {
                element = element->next_sibling_elem(name.data());
            }
            return element;
        }

        static void                  xml_save_map_to_file(std::unordered_map<std::string_view, msvc_xml::document>& map, std::string_view ext, std::string_view rootdir = "") {
            for (auto& [target_name, doc] : map) {
                std::filesystem::path path = (std::filesystem::path(rootdir) / (std::string(target_name) + std::string(ext))).lexically_normal();
                doc.SaveFile(path.generic_string().c_str());
            }
        }

        static msvc_xml::element* xml_find_child_with_attribute(std::string_view name, msvc_xml::element* root, std::string_view attrib, std::string_view value) {
            root = root->begin_child_elem(name.data());
            for (; value != root->get_attrib(attrib.data()); root = root->next_sibling_elem(name.data())) {}
            return root;
        }
        
        static std::string generate_guid() {
            std::random_device rd{};
            std::default_random_engine eng{ rd() };
            std::uniform_int_distribution<std::size_t> distrib{};
    
            return std::format("{{{:08X}-{:04X}-{:04X}-{:04X}-{:08X}{:04X}}}",
                distrib(eng) % 0xFFFFFFFF, distrib(eng) % 0xFFFF, distrib(eng) % 0xFFFF, distrib(eng) % 0xFFFF,
                distrib(eng) % 0xFFFFFFFF, distrib(eng) % 0xFFFF);
        }

        static const char* get_project_type_string(target_types type) {
            static const char* types[] = { "",  "Application", "StaticLibrary", "DynamicLibrary" };
            return types[static_cast<std::uint32_t>(type)];
        }

        static const char* get_cpp_standard_string(target_cpp_standards standard) {
            static const char* standards[] = { "", "stdcpplatest", "stdcpp11", "stdcpp14", "stdcpp17", "stdcpp20", "stdcpp23", "stdcpp26" };
            return standards[static_cast<std::uint32_t>(standard)];
        }

        static const char* get_c_standard_string(target_c_standards standard) {
            static const char* standards[] = { "", "stdclatest", "stdc11", "stdc17", "stdc23" };
            return standards[static_cast<std::uint32_t>(standard)];
        }

        static const char* get_subsystem_string(target_msvc_subsystems sys) {
            static const char* systems[] = { "", "Console", "Windows" };
            return systems[static_cast<std::uint32_t>(sys)];
        }

        static const char* get_optimization_string(target_optimizations op) {
            static const char* optimizations[] = { "",  "Disabled", "MinSpace", "MaxSpeed", "Full" };
            return optimizations[static_cast<std::uint32_t>(op)];
        }

        static msvc_xml::element* find_item_definition_group_element(msvc_xml::document& doc, std::string_view condition, std::string_view subrange) {
            return xml_find_child_with_attribute("ItemDefinitionGroup",
                doc.root_elem(),
                "Condition", condition)->begin_child_elem(subrange.data());
        }
        
        static auto  extract_config(std::string_view config) {
            std::size_t      split = config.find('_');
            std::string      mode(config.substr(split + 1));
            std::string      plat(config.substr(0, split));
            std::string      tag  = std::format("{:s}|{:s}", mode, plat);
            std::string      comb = std::format("'$(Configuration)|$(Platform)'=='{:s}'",tag);
            return std::make_tuple(mode, plat, tag, comb);
        }

        static void  generate_resource(std::string_view target_name, std::string_view iconname) {
            std::ofstream rc(std::string(target_name) + ".rc"), header(std::string(target_name) + ".resource.h");

            rc << std::format(R"(
// Microsoft Visual C++ generated resource script.
//
#include "{0:s}.resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "{0:s}.resource.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#include ""winres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Icon
//

// Icon with lowest ID value placed first to ensure application icon
// remains consistent on all systems.
IDI_ICON1               ICON                    "{1:s}"

#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED)", target_name, iconname);

            header << R"(
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
//
#define IDI_ICON1                       101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
)";
            rc.close();
            header.close();
        }
    }

    /////////////////////////////////////////////////////////////
    //     Header and Sources only have little differences.    //
    /////////////////////////////////////////////////////////////
    
    void visual_studio_project::target_attach_files_(std::string_view target_name, const std::vector<std::string>& files,
                                                     const std::string& filter_root, AttachmentType type) {
        static const char* itemStrings[] = { "", "ClInclude", "ClCompile", "Image", "ResourceCompile" };
        
        // Add filter to list.
        msvc_xml::document& docfilt = vcxproj_filters_map_[target_name];
        msvc_xml::element*  itemGroupFileFilter = msvc_details::xml_find_child_with_index("ItemGroup", docfilt.root_elem(), type);

        std::string absrt =  std::filesystem::absolute(std::filesystem::path(filter_root).lexically_normal()).generic_string();
        
        for (auto& path : files) {
#define GET_ABS_PATH(abspath)\
        auto abspath = std::filesystem::absolute(std::filesystem::path(path).lexically_normal()).remove_filename().generic_string();\
        abspath.erase(0, absrt.size());\
        abspath = msvc_details::get_filter_path(abspath);\
        if (!abspath.empty() && abspath.back() == '\\') { abspath.pop_back(); }
            
            GET_ABS_PATH(abspath)
            if (!abspath.empty()) {
                vcxproj_filter_name_map_[abspath] = abspath;
                msvc_details::xml_find_child_with_index("ItemGroup", docfilt.root_elem())
                ->insert_child_elem("Filter")->set_attrib("Include", abspath.data())
                ->insert_child_elem("UniqueIdentifier")->set_txt(msvc_details::generate_guid().c_str());
            }
        }
        
        msvc_xml::document& docproj = vcxproj_map_[target_name];
        msvc_xml::element*  itemGroupFiles = msvc_details::xml_find_child_with_index("ItemGroup", docproj.root_elem(), type);

        for (auto& path : files) {
            itemGroupFiles->insert_child_elem(itemStrings[type])->set_attrib("Include", path.c_str());
            
            msvc_xml::element* fclItem = itemGroupFileFilter->insert_child_elem(itemStrings[type]);
            fclItem->set_attrib("Include", path.c_str());

            GET_ABS_PATH(abspath)
            if (!abspath.empty()) {
                fclItem->insert_child_elem("Filter")->set_txt(abspath.data());
            }
        }
    }

    void visual_studio_project::target_set_item_definition_group_(std::string_view target_name, std::string_view config,
        std::string_view scope, std::string_view elem, std::string_view value) {
        auto [mode, plat, tag, comb] = msvc_details::extract_config(config);
        msvc_details::find_item_definition_group_element(vcxproj_map_[target_name], comb,
    scope.data())->insert_child_elem(elem.data())->set_txt(value.data());
    }

    void visual_studio_project::target_append_property_group_(std::string_view target_name, std::string_view condition,
        std::string_view scope, std::string_view value) {
        auto [mode, plat, tag, comb] = msvc_details::extract_config(condition);
        auto prop = msvc_details::xml_find_child_with_attribute("PropertyGroup", vcxproj_map_[target_name].root_elem(), "Label", "UserMacros")
        ->next_sibling_elem("PropertyGroup");
        for (;comb != prop->get_attrib("Condition"); prop = prop->next_sibling_elem("PropertyGroup")) {}
        prop->insert_child_elem(scope.data())->set_txt(value.data());
    }


    visual_studio_project::visual_studio_project(std::string_view sln_name, const std::vector<std::string>& configs)
    : solution_name_(sln_name), solution_configs_(configs) {
        
    }

    visual_studio_project& visual_studio_project::new_target(std::string_view target_name) {

        ////////////////////////////////////////////
        //                Filters                ///
        ////////////////////////////////////////////
        msvc_xml::document& docfilt = vcxproj_filters_map_[target_name];
        docfilt.insert_child_end(docfilt.make_decl("xml version=\"1.0\" encoding=\"utf-8\""));
        docfilt.insert_child_end(docfilt.make_comm("Project generated by makeplusplus"));
        
        // Insert filter root project.
        msvc_xml::element* filter = docfilt.make_elem("Project");
        filter->set_attrib("ToolsVersion", "4.0")->set_attrib("xmlns", "http://schemas.microsoft.com/developer/msbuild/2003");
        docfilt.insert_child_end(filter);

        filter->insert_comm("Global   filter defines")->parent_elem()->insert_child_elem("ItemGroup");
        filter->insert_comm("Header   filter defines")->parent_elem()->insert_child_elem("ItemGroup");
        filter->insert_comm("Source   filter defines")->parent_elem()->insert_child_elem("ItemGroup");
        filter->insert_comm("Icon     filter defines")->parent_elem()->insert_child_elem("ItemGroup");
        filter->insert_comm("Resource filter defines")->parent_elem()->insert_child_elem("ItemGroup");
        
        ////////////////////////////////////////////
        //                Project                ///
        ////////////////////////////////////////////
        vcxproj_guid_map_[target_name] = msvc_details::generate_guid();
        msvc_xml::document& docproj = vcxproj_map_[target_name];

        docproj.insert_child_end(docproj.make_decl("xml version=\"1.0\" encoding=\"utf-8\""));
        docproj.insert_child_end(docproj.make_comm("Project generated by makeplusplus"));

        // Insert project root declarations.
        msvc_xml::element* project = docproj.make_elem("Project");
        project->set_attrib("DefaultTargets", "Build")->set_attrib("xmlns", "http://schemas.microsoft.com/developer/msbuild/2003");
        docproj.insert_child_end(project);

        // Insert ItemGroup project configurations
        msvc_xml::element* itemGroupConfig = project->insert_child_elem("ItemGroup")->set_attrib("Label", "ProjectConfigurations");
        for (std::string_view config : solution_configs_) {
            auto[mode, plat, tag, comb] = msvc_details::extract_config(config);
            itemGroupConfig->insert_child_elem("ProjectConfiguration")->set_attrib("Include", tag.c_str())
            ->insert_child_elem("Configuration")->set_txt(mode.c_str()) ->parent_elem()
            ->insert_child_elem("Platform")     ->set_txt(plat.c_str()) ->parent_elem();
        }

        // Insert global configurations
        project->insert_child_elem("PropertyGroup")->set_attrib("Label", "Globals")
        ->insert_child_elem("ProjectGuid")                  ->set_txt(vcxproj_guid_map_[target_name].c_str()) ->parent_elem()
        ->insert_child_elem("RootNamespace")                ->set_txt(target_name.data())                     ->parent_elem()
        ->insert_child_elem("ProjectName")                  ->set_txt(target_name.data())                     ->parent_elem()
        ->insert_child_elem("WindowsTargetPlatformVersion") ->set_txt("10.0");
        
        // Import compile properties
        project->insert_child_elem("Import")->set_attrib("Project", "$(VCTargetsPath)\\Microsoft.Cpp.Default.props");

        // Insert configuration.
        for (std::string_view config : solution_configs_) {
            auto[mode, plat, tag, comb] = msvc_details::extract_config(config);
            std::string mode_upper_norm = msvc_details::normalize_to_uppercase_mode(mode);
            
            project->insert_child_elem("PropertyGroup")
            ->set_attrib("Condition", comb.c_str())->set_attrib("Label", "Configuration")
            ->insert_child_elem("ConfigurationType") ->set_txt("")            ->parent_elem()
            ->insert_child_elem("PlatformToolset")   ->set_txt("v143")        ->parent_elem()
            ->insert_child_elem("CharacterSet")      ->set_txt("Unicode")     ->parent_elem()
            ->insert_child_elem("UseDebugLibraries") ->set_txt(mode_upper_norm == "DEBUG" ? "true" : "false");
        }
        project->insert_child_elem("Import")->set_attrib("Project", "$(VCTargetsPath)\\Microsoft.Cpp.props");

        // Import extension property list.
        project->insert_child_elem("ImportGroup")->set_attrib("Label", "ExtensionSettings");
        project->insert_child_elem("ImportGroup")->set_attrib("Label", "Shared");

        // Use for loop to set all config releated properties.
        for (std::string_view config : solution_configs_) {
            auto[mode, plat, tag, comb] = msvc_details::extract_config(config);
            project->insert_child_elem("ImportGroup")
            ->set_attrib("Label", "PropertySheets")->set_attrib("Condition", comb.c_str())
            ->insert_child_elem("Import")
            ->set_attrib("Project", "$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props")
            ->set_attrib("Condition", "exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')")
            ->set_attrib("Label", "LocalAppDataPlatform");
        }

        project->insert_child_elem("PropertyGroup")->set_attrib("Label", "UserMacros");
        
        for (std::string_view config : solution_configs_) {
            auto[mode, plat, tag, comb] = msvc_details::extract_config(config);
            project->insert_child_elem("PropertyGroup")->set_attrib("Condition", comb.c_str());
        }
        
        // Insert item definitions.
        for (std::string_view config : solution_configs_) {
            auto[mode, plat, tag, comb] = msvc_details::extract_config(config);

            std::string mode_upper_norm = msvc_details::normalize_to_uppercase_mode(mode);
            
            auto* idg = project->insert_child_elem("ItemDefinitionGroup")->set_attrib("Condition", comb.c_str());
            
            auto* com = idg->insert_child_elem("ClCompile");
                  com->insert_child_elem("WarningLevel")        ->set_txt("Level3")  ->parent_elem()
                     ->insert_child_elem("SDLCheck")            ->set_txt("true")    ->parent_elem()
                     ->insert_child_elem("ConformanceMode")     ->set_txt("true")    ->parent_elem();
            auto* lnk = idg->insert_child_elem("Link");
                  lnk->insert_child_elem("GenerateDebugInformation")  ->set_txt("true")    ->parent_elem();
            // Release specific defines
            if (mode_upper_norm != "DEBUG") {
                com->insert_child_elem("FunctionLevelLinking")->set_txt("true")    ->parent_elem()
                   ->insert_child_elem("IntrinsicFunctions")  ->set_txt("true")    ->parent_elem();
                lnk->insert_child_elem("EnableCOMDATFolding") ->set_txt("true")    ->parent_elem()
                   ->insert_child_elem("OptimizeReferences")  ->set_txt("true")    ->parent_elem();
            }
        }

        // include item group sequence 'project configuration''include' 'compile' 'icon' ‘resource’ 'dependencies' 
        project->insert_comm("Include items")   ->parent_elem()->insert_child_elem("ItemGroup");
        project->insert_comm("Source items")    ->parent_elem()->insert_child_elem("ItemGroup");
        project->insert_child_elem("Import")     ->set_attrib("Project", "$(VCTargetsPath)\\Microsoft.Cpp.targets");
        project->insert_child_elem("ImportGroup")->set_attrib("Label", "ExtensionTargets");
        project->insert_comm("Icon Item")       ->parent_elem()->insert_child_elem("ItemGroup");
        project->insert_comm("Resource Item")   ->parent_elem()->insert_child_elem("ItemGroup");
        project->insert_comm("Dependency items")->parent_elem()->insert_child_elem("ItemGroup");
        
        return *this;
    }

    visual_studio_project& visual_studio_project::target_headers(std::string_view target_name,
        const std::vector<std::string>& headers, const std::string& filter) {
        target_attach_files_(target_name, headers, filter, Attach_Headers);
        return *this;        
    }

    visual_studio_project& visual_studio_project::target_sources(std::string_view target_name,
        const std::vector<std::string>& sources, const std::string& filter) {
        target_attach_files_(target_name, sources, filter, Attach_Sources);
        return *this;
    }

    visual_studio_project& visual_studio_project::target_msvc_icon(std::string_view target_name, std::string_view resource) {
        msvc_details::generate_resource(target_name, resource);
        target_attach_files_(target_name, {std::filesystem::absolute(resource).generic_string()}, "./", Attach_Icon);
        target_attach_files_(target_name, {std::filesystem::absolute(std::string(target_name) + ".rc").generic_string()}, "./", Attach_Resource);
        return *this;
    }

    visual_studio_project& visual_studio_project::target_dependencies(std::string_view target_name,
        const std::vector<std::string>& dependencies) {
        msvc_xml::document& docproj   = vcxproj_map_[target_name];
        msvc_xml::element*  itemGroup = msvc_details::xml_find_child_with_index("ItemGroup", docproj.root_elem(), Attach_Dependency);
        for (std::string_view dependency : dependencies) {
            itemGroup->insert_child_elem("ProjectReference")->set_attrib("Include",  (std::string(dependency) + ".vcxproj").c_str())
            ->insert_child_elem("Project")->set_txt(vcxproj_guid_map_[dependency].c_str());
        }
        return *this;
    }

    visual_studio_project& visual_studio_project::target_type(std::string_view target_name, target_types type) {
        msvc_xml::document& docproj   = vcxproj_map_[target_name];
        msvc_xml::element*  propgroup = msvc_details::xml_find_child_with_index("PropertyGroup", docproj.root_elem(), 1);
        for (auto& config : solution_configs_) {
            propgroup->begin_child_elem("ConfigurationType")->set_txt(msvc_details::get_project_type_string(type));
            propgroup = propgroup->next_sibling_elem("PropertyGroup");
        }
        return *this;
    }

    visual_studio_project& visual_studio_project::target_std_cpp(std::string_view target_name,
        target_cpp_standards  version) {
        for (auto& config : solution_configs_) {
            target_set_item_definition_group_(target_name, config,
                "ClCompile", "LanguageStandard", msvc_details::get_cpp_standard_string(version));
        }
        return *this;
    }

    visual_studio_project& visual_studio_project::target_std_c(std::string_view target_name,
        target_c_standards version) {
        for (auto& config : solution_configs_) {
            target_set_item_definition_group_(target_name, config,
                "ClCompile", "LanguageStandard_C", msvc_details::get_c_standard_string(version));
        }
        return *this;
    }

    visual_studio_project& visual_studio_project::target_msvc_subsystem(std::string_view target_name,
        target_msvc_subsystems sys) {
        for (auto& config : solution_configs_) {
            target_set_item_definition_group_(target_name, config,
                "Link", "SubSystem", msvc_details::get_subsystem_string(sys));
        }
        return *this;
    }

    visual_studio_project& visual_studio_project::target_optimization(std::string_view target_name, target_optimizations op, std::string_view config) {
        target_set_item_definition_group_(target_name, config,
    "ClCompile", "Optimization", msvc_details::get_optimization_string(op));
        return *this;
    }

    visual_studio_project& visual_studio_project::target_defines(std::string_view target_name, const std::vector<std::string>& defines, std::string_view config) {
        auto nmode = msvc_details::normalize_to_uppercase_mode(std::get<0>(msvc_details::extract_config(config)));
        std::string_view mac = nmode == "DEBUG" ? "_DEBUG" : "NDEBUG";
        target_set_item_definition_group_(target_name, config,
            "ClCompile", "PreprocessorDefinitions", std::format("{:s};{:s};%(PreprocessorDefinitions)",
                msvc_details::convert_list_to_string(defines, "", [](const std::string& i) { return i; }), mac));
        return *this;
    }

    visual_studio_project& visual_studio_project::target_external_link_directories(std::string_view target_name,
        const std::vector<std::string>& dirs) {
        for (auto& config : solution_configs_) {
            target_set_item_definition_group_(target_name, config,
        "Link", "AdditionalLibraryDirectories",
        msvc_details::convert_list_to_string(dirs, "", [](const std::string& i) {
                     return std::filesystem::path(i).lexically_normal().generic_string();
            }));
        }
        return *this;
    }

    visual_studio_project& visual_studio_project::target_external_include_directories(std::string_view target_name,
        const std::vector<std::string>& dirs) {
        for (auto& config : solution_configs_) {
            target_set_item_definition_group_(target_name, config,
        "ClCompile", "AdditionalIncludeDirectories",
        msvc_details::convert_list_to_string(dirs, "", [](const std::string& i) {
                     return std::filesystem::path(i).lexically_normal().generic_string();
            }));
        }
        return *this;
    }

    visual_studio_project& visual_studio_project::target_external_links(std::string_view target_name, const std::vector<std::string>& links, std::string_view config) {
        target_set_item_definition_group_(target_name, config,
            "Link", "AdditionalDependencies",
            std::format("{:s};%(AdditionalDependencies)", msvc_details::convert_list_to_string(links, ".lib",
                 [](const std::string& i) { return i; })));
        return *this;
    }

    visual_studio_project& visual_studio_project::target_binary_directory(std::string_view target_name, std::string_view dir, std::string_view config) {
        target_append_property_group_(target_name, config, "OutDir", dir);
        return *this;
    }

    visual_studio_project& visual_studio_project::target_intermediate_directory(std::string_view target_name, std::string_view dir, std::string_view config) {
        target_append_property_group_(target_name, config, "IntDir", dir);
        return *this;
    }

    void visual_studio_project::save_project_to_file(std::string_view root) {
        // Solution file generator generates only the necessary part
        // Won't contain visual studio version.
        std::ofstream solution(std::filesystem::path(root) / (solution_name_ + ".sln"));
        solution << "Microsoft Visual Studio Solution File, Format Version 12.00\n";
        std::string sln_guid = msvc_details::generate_guid();
        for (const auto target : vcxproj_guid_map_ | std::views::keys) {
            solution << std::format("Project(\"{0:s}\") = \"{1:s}\", \"{1:s}.vcxproj\", \"{2:s}\"\n", sln_guid, target, vcxproj_guid_map_[target]);
            solution << "EndProject\n";
        }
        solution << "Global\n";
        solution << "    GlobalSection(SolutionConfigurationPlatforms) = preSolution\n";
        for (auto& config : solution_configs_) {
            auto[mode, plat, tag, comb] = msvc_details::extract_config(config);
            solution << std::format("        {0:s} = {0:s}\n", tag);
        }
        solution << "    EndGlobalSection\n";
        solution << "    GlobalSection(ProjectConfigurationPlatforms) = postSolution\n";
        for (auto& guid : vcxproj_guid_map_ | std::views::values) {
            for (auto& config : solution_configs_) {
                auto[mode, plat, tag, comb] = msvc_details::extract_config(config);
                solution << std::format("        {0:s}.{1:s}.ActiveCfg = {1:s}\n", guid, tag);
                solution << std::format("        {0:s}.{1:s}.Build.0 = {1:s}\n", guid, tag);
            }
        }
        solution << "    EndGlobalSection\n";
        solution << "	 GlobalSection(SolutionProperties) = preSolution\n";
        solution << "        HideSolutionNode = FALSE\n";
        solution << "    EndGlobalSection\n";
        solution << "EndGlobal";
        solution.close();
    }

    void visual_studio_project::save_targets_to_files(std::string_view root) {
        msvc_details::xml_save_map_to_file(vcxproj_map_, ".vcxproj", root);
        msvc_details::xml_save_map_to_file(vcxproj_filters_map_, ".vcxproj.filters", root);
    }

    ////////////////////////////////////////////////////////////////////////////////////
    ///                                Real Application                              ///
    ////////////////////////////////////////////////////////////////////////////////////

    void make_application::generate_header_() {
        std::ofstream header("makexx.generated.hpp");
        header << put_header_archive_to_buffer({
            {"MXX_PROJECT_ROOT", std::format("\"{:s}/\"", std::filesystem::current_path().parent_path().generic_string())}
        });
        header.close();
        std::cout << "Header generated!\n";
    }

    void make_application::generate_project_() {
        if (argc_ < 3) {
            std::cout << "Error, must have project name argument!\n";
            return;
        }
        std::string_view project_name = argv_[2];
        if (!std::filesystem::exists("makexx.generated.hpp")) {
            generate_header_();
        }
        std::ofstream project(std::format("../{:s}.make.hpp", project_name));
        project << "// Makeplusplus project!\n";
        project << std::format("#include \"{:s}/makexx.generated.hpp\"\n\n", std::filesystem::current_path().filename().generic_string());
        project << std::format("PROJECT_NAME = \"{:s}\";\n", project_name);
        project << "PROJECT_TARGETS = {\"\"};\n";
        project << "PROJECT_CONFIGURATIONS = {\"\"};\n\n";
        project << "#pragma target_definitions\n";
        project.close();
        std::cout << std::format("Project description \"{:s}\" has been written to \"{:s}\"\n", project_name, std::filesystem::current_path().generic_string());
    }

    void make_application::read_current_definition_map_() {
        std::ifstream     header("./makexx.generated.hpp");
        std::stringstream strbuf;
        strbuf << header.rdbuf();
        static cpod::archive static_archive(std::move(strbuf.str()));
        get_header_archive_from_buffer(static_archive, definition_map_);
    }

    void make_application::read_source_and_split_targets_() {
        read_current_definition_map_();
        
        if (argc_ < 3) {
            std::cout << "Error, must have project description path argument!\n";
            return;
        }
        std::string_view project_desc_path = argv_[2];
        std::ifstream ifs(project_desc_path.data());

        if (!ifs.good()) {
            std::cout << "Error, invalid description path!\n";
            return;
        }

        std::string   source_cache;
        bool          before_first_namespace = true;
        std::size_t   scope_count = 0;
        std::string   current_scope_name;

        // Split all targets.
        for (std::string line_cache; std::getline(ifs, line_cache);) {
            if (before_first_namespace) {
                if (line_cache == "#pragma target_definitions") {
                    before_first_namespace = false;
                    mxx_project_source_fields_["project_scope"] = source_cache;
                    source_cache.clear();
                }
                else {
                    if (line_cache.find("#include") == std::string::npos) {
                        source_cache += line_cache;
                        source_cache.push_back('\n');
                    }
                }
            }
            else {
                if (auto b = line_cache.find("namespace"); b != std::string::npos) {
                    // The first one.
                    std::size_t end = line_cache.find(' ', b + 10);
                    std::string scope_name_cache = line_cache.substr(b + 10, end - b - 10);
                    if (scope_count == 0) {
                        current_scope_name = scope_name_cache;
                    } else {
                        source_cache += std::format("#pragma target_config {:s}\n", scope_name_cache);
                    }
                    ++scope_count;
                }
                else {
                    if (line_cache.find('{') != std::string::npos) {
                        ++scope_count;
                    }
                    if (line_cache.find('}') != std::string::npos) {
                        if (scope_count == 1) {
                            mxx_project_source_fields_[current_scope_name] = source_cache;
                            source_cache.clear();
                        }
                        --scope_count;
                    }
                    std::erase_if(line_cache, [](auto& it){ return std::isspace(it) && std::isspace((&it)[1]); });
                    if (line_cache != " }") {
                        source_cache += line_cache;
                        source_cache.push_back('\n');
                    }
                }
            }
        }
        
        // Read project scope data.
        cpod::archive project_scope(mxx_project_source_fields_["project_scope"]);
        project_scope.compile_content_default(definition_map_);

        project_scope
        >> cpod::var("mxx_project_name", mxx_project_name_)
        >> cpod::var("mxx_project_targets", mxx_project_targets_)
        >> cpod::var("mxx_project_configurations", mxx_project_configurations_);
    }


    namespace generator_details {
        template <class Ty>
        static constexpr Ty no_operation(const Ty& v) {
            return v;
        }

        template <class E>
        static constexpr E  enum_convert(auto e) {
            return static_cast<E>(e);
        }

        static std::vector<std::string> unwrap_shrunk_path(const std::string& path) {
            // Current only support **.ext and *.ext !
            auto absp = std::filesystem::absolute(path);
            auto ext = absp.extension();
            std::vector<std::string> result_paths;
    
            if (path.find("**") != std::string::npos) {
                for (auto p = std::filesystem::recursive_directory_iterator(absp.parent_path());
                    p != std::filesystem::recursive_directory_iterator(); ++p) {
                    if (p->path().extension() == ext) {
                        result_paths.emplace_back(p->path().generic_string());
                    }
                }
                return result_paths;
            }
            if (path.find("*") != std::string::npos) {
                for (auto p = std::filesystem::directory_iterator(absp.parent_path());
                    p != std::filesystem::directory_iterator(); ++p) {
                    if (p->path().extension() == ext) {
                        result_paths.emplace_back(p->path().generic_string());
                    }
                }
                return result_paths;
            }
            return {path};
        }

        static std::vector<std::string> unwrap_shrunk_paths(const std::vector<std::string>& paths) {
            std::vector<std::string> result;
            for (const auto& path : paths) {
                std::vector<std::string> unwripped = unwrap_shrunk_path(path);
                result.insert(result.end(), unwripped.begin(), unwripped.end());
            }
            return result;
        }
    }

    ////////////////////////////////////////////////////////////
    //            Also belongs to generator                   //
    ////////////////////////////////////////////////////////////
    
    std::string make_application::fix_path_(std::string_view path) {
        std::string root = definition_map_["MXX_PROJECT_ROOT"];
        std::erase(root, '\"');
        return (std::filesystem::path(root) / path).lexically_normal().generic_string();
    }

    std::vector<std::string> make_application::fix_paths_(std::vector<std::string>& paths) {
        for (auto& path : paths) {
            path = fix_path_(path);
        }
        return generator_details::unwrap_shrunk_paths(paths);
    }
    
    void makexx::make_application::read_target_and_generate_vs_project_(const std::string& target, const std::string& source, visual_studio_project& vssln) {
        std::stringstream strbuf;
        strbuf << source << '\n' << "#pragma target_config end";

#define FIND_AND_SET_PROPERTY(fn, hd, ...) do { \
if (current_archive.find_variable_begin<decltype(mxx_##fn)>("mxx_"#fn) != current_archive.content_end()) {\
current_archive >> cpod::var("mxx_"#fn, mxx_##fn);\
auto hd_var = hd(mxx_##fn);                          \
vssln.fn(target, hd_var,__VA_ARGS__);           \
}} while (false)
        
        std::string      splited_source;
        std::size_t      config_count = 0;
        std::string      current_config;
        
        for (std::string line_cache; std::getline(strbuf, line_cache);) {
            if (std::memcmp(line_cache.c_str(), "#pragma target_config ", 22) == 0) {
                cpod::archive    current_archive(splited_source);
                current_archive.compile_content_default(definition_map_);
                if (config_count == 0) {
                    // Variables needed to be loaded.
                    std::vector<std::string> mxx_target_headers;
                    std::vector<std::string> mxx_target_sources;
                    std::vector<std::string> mxx_target_dependencies;
                    std::vector<std::string> mxx_target_external_link_directories;
                    std::vector<std::string> mxx_target_external_include_directories;

                    std::string              mxx_target_msvc_icon;
                    std::uint32_t            mxx_target_type;
                    std::uint32_t            mxx_target_std_cpp;
                    std::uint32_t            mxx_target_std_c;
                    std::uint32_t            mxx_target_msvc_subsystem;

                    auto filter_root = fix_path_("");
                    
                    FIND_AND_SET_PROPERTY(target_sources,                        fix_paths_, filter_root);
                    FIND_AND_SET_PROPERTY(target_headers,                        fix_paths_, filter_root);
                    FIND_AND_SET_PROPERTY(target_msvc_icon,                      fix_path_);
                    FIND_AND_SET_PROPERTY(target_dependencies,                   generator_details::no_operation);
                    FIND_AND_SET_PROPERTY(target_type,                           generator_details::enum_convert<target_types>);
                    FIND_AND_SET_PROPERTY(target_std_cpp,                        generator_details::enum_convert<target_cpp_standards>);
                    FIND_AND_SET_PROPERTY(target_std_c,                          generator_details::enum_convert<target_c_standards>);
                    FIND_AND_SET_PROPERTY(target_msvc_subsystem,                 generator_details::enum_convert<target_msvc_subsystems>);
                    FIND_AND_SET_PROPERTY(target_external_link_directories,      fix_paths_);
                    FIND_AND_SET_PROPERTY(target_external_include_directories,   fix_paths_);
                    ++config_count;
                }
                else {
                    // Means the config we use is not available.
                    if (std::ranges::find(mxx_project_configurations_, current_config) == mxx_project_configurations_.end()) {
                        std::cout << "You are defining a configuration namespace that has not declared in PROJECT_CONFIGURATIONS!";
                        std::exit(0);
                    }
                    
                    std::vector<std::string> mxx_target_defines;
                    std::vector<std::string> mxx_target_external_links;
                    std::string              mxx_target_binary_directory;
                    std::string              mxx_target_intermediate_directory;
                    std::uint32_t            mxx_target_optimization;
                    
                    FIND_AND_SET_PROPERTY(target_optimization,            generator_details::enum_convert<target_optimizations>, current_config);
                    FIND_AND_SET_PROPERTY(target_defines,                 generator_details::no_operation,                       current_config);
                    FIND_AND_SET_PROPERTY(target_external_links,          generator_details::no_operation,                       current_config);
                    FIND_AND_SET_PROPERTY(target_intermediate_directory,  fix_path_,                          current_config);
                    FIND_AND_SET_PROPERTY(target_binary_directory,        fix_path_,                          current_config);
                    ++config_count;
                }
                splited_source.clear();
                current_config = line_cache.substr(22);
            } else {
                splited_source += line_cache;
                splited_source.push_back('\n');
            }
        }
        
    }

    void make_application::generate_actual_visual_studio_project_() {
        std::chrono::high_resolution_clock::time_point start_time = std::chrono::high_resolution_clock::now();
        std::cout << "----------------------------------------------------------------------------------------------\n";
        read_source_and_split_targets_();
        std::cout << std::format("Makepluplus project descriptor {:s} parsing complete!\n", argv_[2]);
        std::cout << "Generating project using \"Visual Studio Generator\"!\n";
        visual_studio_project vssln(mxx_project_name_, mxx_project_configurations_);

        for (auto& target : mxx_project_targets_) {
            vssln.new_target(target);
        }
        
        for (auto& target : mxx_project_targets_) {
            auto& source = mxx_project_source_fields_[target];
            read_target_and_generate_vs_project_(target, source, vssln);
            std::cout << std::format("VC++ Project {:s} generated!\n", target);
        }

        std::filesystem::create_directory(mxx_project_name_);
        vssln.save_targets_to_files(mxx_project_name_);
        vssln.save_project_to_file(mxx_project_name_);
        
        std::chrono::high_resolution_clock::time_point end_time = std::chrono::high_resolution_clock::now();
        std::chrono::duration<double> elapsed_seconds = end_time - start_time;
        std::cout << std::format("Visual Studio Solution {:s} generated!\n",mxx_project_name_);
        std::cout << std::format("Total time used: {}\n", elapsed_seconds);
        std::cout << "----------------------------------------------------------------------------------------------\n";
    }

    make_application::make_application(int argc, char** argv) : argc_(argc), argv_(argv) {
    }

    int make_application::operator()() {
        using namespace std::string_view_literals;
        if (argc_ == 1) {
            std::cout << s_hello_message << std::endl;
            return 0;
        }
        // Generate project
        if      ("-gh"sv    == argv_[1])    { generate_header_(); }
        else if ("-gp"sv    == argv_[1])    { generate_project_(); }
        else if ("-gv"sv    == argv_[1])    { generate_actual_visual_studio_project_(); }
        else if ("-h"sv     == argv_[1]  ||
                 "--help"sv == argv_[1])    {
            std::cout << s_help_message << std::endl;
        }
        return 0;
    }
}
